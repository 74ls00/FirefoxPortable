<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.1//EN' 'http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd'>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Programming Arduino™ Next Steps: Going Further with Sketches</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"></meta>
<link href="stylesheet.css" type="text/css" rel="stylesheet"></link>

<!-- kobo-style -->
<link type="text/css" rel="stylesheet" href="css/kobo.css"></link>
<script type="text/javascript" src="js/kobo.js"></script>
<style type="text/css" id="kobostylehacks">div#book-inner p, div#book-inner div { font-size: 1.0em; } a { color: black; } a:link, a:visited, a:hover, a:active { color: blue; } div#book-inner * { margin-top: 0 !important; margin-bottom: 0 !important;}</style>
</head>
<body><div id="book-columns"><div id="book-inner">
<div class="chapnum" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.1.1">7</span></span></div>
<div class="chaptitle" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.2.1">Using I2C</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="big"><span class="koboSpan" id="kobo.3.1">The I2C</span></span><span class="koboSpan" id="kobo.4.1"> (pronounced “I squared C”) interface bus is a standard for connecting microcontrollers and peripherals together. </span><span class="koboSpan" id="kobo.4.2">I2C is sometimes referred to as Two Wire Interface (TWI). </span><span class="koboSpan" id="kobo.4.3">All the Arduino boards have at least one I2C interface to which you can attach a wide range of peripherals. </span><span class="koboSpan" id="kobo.4.4">Some examples are shown in </span><a href="#fig7-1"><span class="koboSpan" id="kobo.5.1">Figure 7-1</span></a><span class="koboSpan" id="kobo.6.1">.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig7-1" class="image"><span><span class="koboSpan" id="kobo.7.1"><img alt="image" src="images/fig7-1.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.8.1">Figure 7-1</span></b><span class="koboSpan" id="kobo.9.1">   </span><i><span class="koboSpan" id="kobo.10.1">A collection of I2C devices</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.11.1">The three devices on the top row of </span><a href="#fig7-1"><span class="koboSpan" id="kobo.12.1">Figure 7-1</span></a><span class="koboSpan" id="kobo.13.1"> are all display modules from Adafruit. </span><span class="koboSpan" id="kobo.13.2">On the bottom row, starting on the left, is a TEA5767 FM receiver module. </span><span class="koboSpan" id="kobo.13.3">You can find these modules on eBay and elsewhere for a few dollars. </span><span class="koboSpan" id="kobo.13.4">The TEA5767 provides you with a full FM receiver module that you can tune to a certain frequency by sending it I2C commands. </span><span class="koboSpan" id="kobo.13.5">In the center is a real-time clock (RTC) module, including an I2C chip and crystal oscillator that maintains a fairly accurate time and date. </span><span class="koboSpan" id="kobo.13.6">Once you have set the date and time over I2C, you can read the time and date back over I2C whenever you need it. </span><span class="koboSpan" id="kobo.13.7">This module also includes a long-life lithium button cell that allows it to keep time, even when the module has no external power. </span><span class="koboSpan" id="kobo.13.8">Finally, on the right, is a 16-channel servo/PWM driver that can give you 16 extra analog outputs from your Arduino.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.14.1">The I2C standard is defined as a “bus” standard because its use is not limited to connecting one component directly to another. </span><span class="koboSpan" id="kobo.14.2">Say you have a display connected to a microcontroller; using the same two bus pins, you can connect a whole set of “slave” devices to a “master” device. </span><span class="koboSpan" id="kobo.14.3">The Arduino acts as the “master,” and each of the “slaves” has a unique address that identifies the device on the bus.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><a href="#fig7-2"><span class="koboSpan" id="kobo.15.1">Figure 7-2</span></a><span class="koboSpan" id="kobo.16.1"> shows a possible arrangement of two I2C components attached to an Arduino, a real-time clock (RTC), and a display module.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig7-2" class="image"><span><span class="koboSpan" id="kobo.17.1"><img alt="image" src="images/fig7-2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.18.1">Figure 7-2</span></b><span class="koboSpan" id="kobo.19.1">   </span><i><span class="koboSpan" id="kobo.20.1">An Arduino controlling two I2C devices</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.21.1">You can also use I2C to connect two Arduinos together so they can exchange data. </span><span class="koboSpan" id="kobo.21.2">In this case, one of the Arduinos will be configured to act as a “master” and one as a “slave.”</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.22.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c7-1" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.23.1">I2C Hardware</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.24.1">Electrically, I2C interfaces connection lines from a microcontroller or peripheral can act as both a digital output or digital input (also called </span><i><span class="koboSpan" id="kobo.25.1">tri-state</span></i><span class="koboSpan" id="kobo.26.1">). </span><span class="koboSpan" id="kobo.26.2">In tri-state mode, the connection lines are neither HIGH nor LOW, but are, instead, a floating value. </span><span class="koboSpan" id="kobo.26.3">The outputs are also </span><i><span class="koboSpan" id="kobo.27.1">open-collector</span></i><span class="koboSpan" id="kobo.28.1">, which means that they require a pull-up resistor. </span><span class="koboSpan" id="kobo.28.2">These resistors should be 4.7 kΩ in value, and there should be just one pair for the whole I2C bus, pulling up to either 3.3V or 5V, depending on the voltage at which you want the bus to operate. </span><span class="koboSpan" id="kobo.28.3">If some devices on the bus use different voltages, you need to use a level converter. </span><span class="koboSpan" id="kobo.28.4">Bidirectional level converter modules suitable for I2C are available, such as the BSS138 device from Adafruit: </span><a href="http://www.adafruit.com/products/757"><span class="koboSpan" id="kobo.29.1">www.adafruit.com/products/757</span></a><span class="koboSpan" id="kobo.30.1">.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.31.1">The various Arduino boards allocate different pins to I2C. </span><span class="koboSpan" id="kobo.31.2">For example, the Uno uses pins A4 and A5 as SDA and SCL, respectively, whereas the Leonardo uses pins D2 and D3. </span><span class="koboSpan" id="kobo.31.3">(More on SDA and SCL in the next section.) On both boards, the SDA and SCL pins are available on the socket header next to the AREF connection (</span><a href="#fig7-3"><span class="koboSpan" id="kobo.32.1">Figure 7-3</span></a><span class="koboSpan" id="kobo.33.1">).</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig7-3" class="image"><span><span class="koboSpan" id="kobo.34.1"><img alt="image" src="images/fig7-3.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.35.1">Figure 7-3</span></b><span class="koboSpan" id="kobo.36.1">   </span><i><span class="koboSpan" id="kobo.37.1">I2C connections on an Arduino Uno</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><a href="#tab7-1"><span class="koboSpan" id="kobo.38.1">Table 7-1</span></a><span class="koboSpan" id="kobo.39.1"> indicates the location of I2C pins on the common Arduino boards.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="tab7-1" class="imagex"><span><span class="koboSpan" id="kobo.40.1"><img alt="image" src="images/tab7-1.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.41.1">Table 7-1</span></b><span class="koboSpan" id="kobo.42.1">   </span><i><span class="koboSpan" id="kobo.43.1">I2C Connections on Arduino Boards</span></i></span></div>
</div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.44.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c7-2" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.45.1">The I2C Protocol</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.46.1">I2C uses two wires to transmit and receive data (hence, the alternative name of Two Wire Interface). </span><span class="koboSpan" id="kobo.46.2">These two lines are called the Serial Clock Line (SCL) and the Serial Data Line (SDA). </span><a href="#fig7-4"><span class="koboSpan" id="kobo.47.1">Figure 7-4</span></a><span class="koboSpan" id="kobo.48.1"> shows the timing diagram for this signal.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig7-4" class="image"><span><span class="koboSpan" id="kobo.49.1"><img alt="image" src="images/fig7-4.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.50.1">Figure 7-4</span></b><span class="koboSpan" id="kobo.51.1">   </span><i><span class="koboSpan" id="kobo.52.1">Timing diagram for I2C</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.53.1">The master supplies the SCL clock, and when there is data to be transmitted, the sender (master or slave) takes the SDA line out of tri-state (digital input mode) and sends data as logic highs or lows in time with the clock signal. </span><span class="koboSpan" id="kobo.53.2">When transmission is complete, the clock can stop and the SDA pin is returned to tri-state.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.54.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c7-3" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.55.1">The Wire Library</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.56.1">You could, of course, generate these pulses yourself by </span><i><span class="koboSpan" id="kobo.57.1">bit banging</span></i><span class="koboSpan" id="kobo.58.1">—that is, turning digital outputs on and off in your code. </span><span class="koboSpan" id="kobo.58.2">To make life easier for us, however, the Arduino software includes a library called Wire that handles all the timing complexity, so we can just send and receive bytes of data.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.59.1">To use the Wire library, you first need to include it using the following command:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.60.1"><img alt="image" src="images/p129-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c7-4" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.61.1">Initializing I2C</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.62.1">In most situations, an Arduino is the “master” in any I2C bus. </span><span class="koboSpan" id="kobo.62.2">To initialize an Arduino as the master, use the </span><b><span class="koboSpan" id="kobo.63.1">begin</span></b><span class="koboSpan" id="kobo.64.1"> command in your </span><b><span class="koboSpan" id="kobo.65.1">setup</span></b><span class="koboSpan" id="kobo.66.1"> function, as shown here:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.67.1"><img alt="image" src="images/p129-02.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.68.1">Note that because the Arduino is the master in this arrangement, you don’t need to specify an address. </span><span class="koboSpan" id="kobo.68.2">If the Arduino were being initialized as a slave, then you would need to specify an address, 0 to 127, as its parameter to uniquely identify it on the I2C bus.</span></span></div>
<div id="c7-5" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.69.1">Master Sending Data</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.70.1">To send data to an I2C device, start by using the </span><b><span class="koboSpan" id="kobo.71.1">beginTransmission</span></b><span class="koboSpan" id="kobo.72.1"> function and specifying the address of the I2C device on the bus that you wish to send data to:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.73.1"><img alt="image" src="images/p129-03.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.74.1">You can either send data to an I2C device one byte at a time, or you can send a </span><b><span class="koboSpan" id="kobo.75.1">char</span></b><span class="koboSpan" id="kobo.76.1"> array, as shown in these two examples:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.77.1"><img alt="image" src="images/p129-04.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.78.1">Finally, at the end of the transmission, use the </span><b><span class="koboSpan" id="kobo.79.1">endTransmission</span></b><span class="koboSpan" id="kobo.80.1"> function:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.81.1"><img alt="image" src="images/p130-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c7-6" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.82.1">Master Receiving Data</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.83.1">For a master to receive data from a slave, it must first request the number of bytes it requires using the </span><b><span class="koboSpan" id="kobo.84.1">requestFrom</span></b><span class="koboSpan" id="kobo.85.1"> function:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.86.1"><img alt="image" src="images/p130-02.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.87.1">The first argument to this function is the address of the slave from which the master wants to receive data, and the second argument is the number of bytes that the master is expecting to receive back. </span><span class="koboSpan" id="kobo.87.2">The slave can return less than this, so the </span><b><span class="koboSpan" id="kobo.88.1">available</span></b><span class="koboSpan" id="kobo.89.1"> function is used to determine both if data has arrived and the number of bytes received. </span><span class="koboSpan" id="kobo.89.2">The following example (taken from the Wire example sketches) shows the master reading all available data from the slave and echoing it to the Serial Monitor:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.90.1"><img alt="image" src="images/p130-03.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.91.1">The Wire library will buffer incoming I2C data.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.92.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c7-7" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.93.1">I2C Examples</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.94.1">Any I2C device should have an accompanying datasheet that specifies the messages that it expects to use. </span><span class="koboSpan" id="kobo.94.2">Sometimes you will need to use that datasheet to build your own messages to send from the Arduino and to interpret the messages that come back. </span><span class="koboSpan" id="kobo.94.3">You’ll often find, however, that when an I2C device is commonly used with an Arduino, then someone has written a library that wraps the I2C messages in nice easy-to-use functions. </span><span class="koboSpan" id="kobo.94.4">In fact, if there isn’t a library and you work out how to use the device, then the socially minded thing to do is to release your library to the world and earn yourself some open source karma.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.95.1">Even if no fully fledged library is available, you can often find useful code snippets for the device on the Internet.</span></span></div>
<div id="c7-8" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.96.1">TEA5767 FM Radio</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.97.1">The first I2C example does not use a library. </span><span class="koboSpan" id="kobo.97.2">It deals with raw messages to interface an Arduino with a TEA5767 module. </span><span class="koboSpan" id="kobo.97.3">These modules are available at a very low cost on the Internet and are easy to connect to an Arduino to use as an Arduino-controlled FM receiver.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.98.1">The tricky part is that the connections on these devices are set at an extremely fine pitch, so you generally need to make or buy some kind of adapter that allows you to use them with breadboard or jumper wires.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><a href="#fig7-5"><span class="koboSpan" id="kobo.99.1">Figure 7-5</span></a><span class="koboSpan" id="kobo.100.1"> shows how this module can be wired to an Arduino.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig7-5" class="image"><span><span class="koboSpan" id="kobo.101.1"><img alt="image" src="images/fig7-5.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.102.1">Figure 7-5</span></b><span class="koboSpan" id="kobo.103.1">   </span><i><span class="koboSpan" id="kobo.104.1">Wiring a TEA5767 module to an Arduino Uno using I2C</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.105.1">You can find the full datasheet for the TEA5767 here: </span><a href="http://www.sparkfun.com/datasheets/Wireless/General/TEA5767.pdf"><span class="koboSpan" id="kobo.106.1">www.sparkfun.com/datasheets/Wireless/General/TEA5767.pdf</span></a><span class="koboSpan" id="kobo.107.1">. </span><span class="koboSpan" id="kobo.107.2">The datasheet contains a lot of technical information about the chip, but if you scroll through the document, you’ll find a section detailing the messages that it expects to receive. </span><span class="koboSpan" id="kobo.107.3">The datasheet specifies that the TEA5767 expects to receive messages of five bytes. </span><span class="koboSpan" id="kobo.107.4">The example code shown next is a fully working example that will tune the frequency once at startup. </span><span class="koboSpan" id="kobo.107.5">In practice, you need some other mechanism, such as push buttons and an LCD display, to set the frequency.</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.108.1"><img alt="image" src="images/p132-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.109.1">The code we’re interested in is all in the </span><b><span class="koboSpan" id="kobo.110.1">setFrequency</span></b><span class="koboSpan" id="kobo.111.1"> function. </span><span class="koboSpan" id="kobo.111.2">This function takes a float as a parameter. </span><span class="koboSpan" id="kobo.111.3">This value is the frequency in MHz. </span><span class="koboSpan" id="kobo.111.4">So if you’re going to build this for real, you might want to look up the frequency of a good local radio station with a strong signal and put the value in the call to </span><b><span class="koboSpan" id="kobo.112.1">setFrequency</span></b><span class="koboSpan" id="kobo.113.1"> in the </span><b><span class="koboSpan" id="kobo.114.1">setup</span></b><span class="koboSpan" id="kobo.115.1"> function.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.116.1">To convert a float frequency in MHz into a two-byte value that can be sent as part of the five-byte message, you need to do some math. </span><span class="koboSpan" id="kobo.116.2">The math is contained in the code:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.117.1"><img alt="image" src="images/p133-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.118.1">The </span><b><span class="koboSpan" id="kobo.119.1">&gt;&gt;</span></b><span class="koboSpan" id="kobo.120.1"> command shifts bits to the right, so using </span><b><span class="koboSpan" id="kobo.121.1">&gt;&gt; 8</span></b><span class="koboSpan" id="kobo.122.1"> shifts the most significant 8 bits into the least significant 8 bit positions. </span><span class="koboSpan" id="kobo.122.2">The </span><b><span class="koboSpan" id="kobo.123.1">&amp;</span></b><span class="koboSpan" id="kobo.124.1"> operator provides a bitwise </span><b><span class="koboSpan" id="kobo.125.1">and</span></b><span class="koboSpan" id="kobo.126.1"> operation, which has the effect of masking off the top 8 bits so only the bottom 8 bits remain. </span><span class="koboSpan" id="kobo.126.2">For more information on this kind of bit manipulation, see </span><a href="ch09.html"><span class="koboSpan" id="kobo.127.1">Chapter 9</span></a><span class="koboSpan" id="kobo.128.1">.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.129.1">The remainder of the </span><b><span class="koboSpan" id="kobo.130.1">setFrequency</span></b><span class="koboSpan" id="kobo.131.1"> function begins transmission of the I2C message to the slave with address </span><b><span class="koboSpan" id="kobo.132.1">0x60</span></b><span class="koboSpan" id="kobo.133.1">, which is fixed for the TEA5767 chip. </span><span class="koboSpan" id="kobo.133.2">It then sends each of the 5 bytes, starting with the 2 frequency bytes.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.134.1">If you read through the datasheet, you’ll discover many other things you can accomplish with different messages, such as scanning, muting one or more channels, and setting the mode to mono or stereo.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.135.1">In the Appendix, we’ll revisit this example, creating an Arduino library so using the TEA5767 can be even simpler.</span></span></div>
<div id="c7-9" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.136.1">Arduino-to-Arduino Communication</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.137.1">This second example uses two Arduinos, one acting as the I2C master and one as the slave. </span><span class="koboSpan" id="kobo.137.2">The master will send messages to the slave, which will, in turn, echo them to the Serial Monitor, so we can see that the communication is working.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.138.1">The connections for this setup are shown in </span><a href="#fig7-6"><span class="koboSpan" id="kobo.139.1">Figure 7-6</span></a><span class="koboSpan" id="kobo.140.1">. </span><span class="koboSpan" id="kobo.140.2">Note that the TEA5767 module has built-in I2C pull-up resistors, but this is not the case when connecting two Arduinos, so you’ll need to provide your own 4.7 kΩ resistors, as shown in </span><a href="#fig7-6"><span class="koboSpan" id="kobo.141.1">Figure 7-6</span></a><span class="koboSpan" id="kobo.142.1">.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig7-6" class="image"><span><span class="koboSpan" id="kobo.143.1"><img alt="image" src="images/fig7-6.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.144.1">Figure 7-6</span></b><span class="koboSpan" id="kobo.145.1">   </span><i><span class="koboSpan" id="kobo.146.1">Connecting two Arduinos using I2C</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.147.1">We need to program each of the two Arduinos with a different sketch. </span><span class="koboSpan" id="kobo.147.2">Both sketches are provided as examples in the Wire library. </span><span class="koboSpan" id="kobo.147.3">Program the master Arduino with File | Example | Wire | master_writer, and the slave Arduino with File | Example | Wire | slave_receiver.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.148.1">Once you’ve programmed both Arduinos, leave the slave Arduino connected to your computer; you need to see the output from this Arduino in the Serial Monitor, and it will also supply power to the master Arduino.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.149.1">Start with the sketch on the master Arduino:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.150.1"><img alt="image" src="images/p134-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.151.1">This code generates messages of the form </span><b><span class="koboSpan" id="kobo.152.1">“x is </span><i><span class="koboSpan" id="kobo.153.1">1</span></i><span class="koboSpan" id="kobo.154.1">”</span></b><span class="koboSpan" id="kobo.155.1"> where </span><i><span class="koboSpan" id="kobo.156.1">1</span></i><span class="koboSpan" id="kobo.157.1"> is a number that is incremented every half second. </span><span class="koboSpan" id="kobo.157.2">This message is then sent to the I2C slave device with the ID of 4, as specified in </span><b><span class="koboSpan" id="kobo.158.1">beginTransmission</span></b><span class="koboSpan" id="kobo.159.1">.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.160.1">The slave sketch’s job is to receive the messages coming from the master and echo them on the Serial Monitor:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.161.1"><img alt="image" src="images/p135-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.162.1">The first thing to notice is that this time the </span><b><span class="koboSpan" id="kobo.163.1">Wire.begin</span></b><span class="koboSpan" id="kobo.164.1"> function has a parameter of </span><b><span class="koboSpan" id="kobo.165.1">4</span></b><span class="koboSpan" id="kobo.166.1">. </span><span class="koboSpan" id="kobo.166.2">This parameter specifies the I2C address of the slave, which is 4. </span><span class="koboSpan" id="kobo.166.3">It must match the address that the master sends the message to.</span></span></div>
<div class="note" xmlns="http://www.w3.org/1999/xhtml"><span><b><i><span class="koboSpan" id="kobo.167.1">TIP</span></i></b><span class="koboSpan" id="kobo.168.1">   </span><i><span class="koboSpan" id="kobo.169.1">You could connect many slave Arduinos to the same two-wire bus as long as each has a different I2C address</span></i><span class="koboSpan" id="kobo.170.1">.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.171.1">The sketch for the slave differs from that of the master because it uses interrupts to respond to the master when a message comes in. </span><span class="koboSpan" id="kobo.171.2">This is accomplished using the </span><b><span class="koboSpan" id="kobo.172.1">onReceive</span></b><span class="koboSpan" id="kobo.173.1"> function, which is invoked like an interrupt service routine (see </span><a href="ch03.html"><span class="koboSpan" id="kobo.174.1">Chapter 3</span></a><span class="koboSpan" id="kobo.175.1">). </span><span class="koboSpan" id="kobo.175.2">Place this in </span><b><span class="koboSpan" id="kobo.176.1">setup</span></b><span class="koboSpan" id="kobo.177.1"> so the user-written function </span><b><span class="koboSpan" id="kobo.178.1">receiveEvent</span></b><span class="koboSpan" id="kobo.179.1"> is invoked whenever a message comes in.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.180.1">The </span><b><span class="koboSpan" id="kobo.181.1">receiveEvent</span></b><span class="koboSpan" id="kobo.182.1"> function is expected to have a single parameter, which indicates the number of bytes ready to be read. </span><span class="koboSpan" id="kobo.182.2">In this case, this number is ignored. </span><span class="koboSpan" id="kobo.182.3">The </span><b><span class="koboSpan" id="kobo.183.1">while</span></b><span class="koboSpan" id="kobo.184.1"> loop first reads all the available characters and echoes each character in turn. </span><span class="koboSpan" id="kobo.184.2">It then reads the single byte number on the end of the message and prints that to the Serial Monitor. </span><span class="koboSpan" id="kobo.184.3">Using </span><b><span class="koboSpan" id="kobo.185.1">println</span></b><span class="koboSpan" id="kobo.186.1"> rather than </span><b><span class="koboSpan" id="kobo.187.1">write</span></b><span class="koboSpan" id="kobo.188.1"> ensures that the value of the byte is displayed rather than its character value (</span><a href="#fig7-7"><span class="koboSpan" id="kobo.189.1">Figure 7-7</span></a><span class="koboSpan" id="kobo.190.1">).</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig7-7" class="image"><span><span class="koboSpan" id="kobo.191.1"><img alt="image" src="images/fig7-7.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.192.1">Figure 7-7</span></b><span class="koboSpan" id="kobo.193.1">   </span><i><span class="koboSpan" id="kobo.194.1">Serial Monitor output for Arduino to Arduino over I2C</span></i></span></div>
</div>
<div id="c7-10" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.195.1">LED Backpack Boards</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.196.1">Another common range of I2C devices are those used for displays. </span><span class="koboSpan" id="kobo.196.2">Of these, the range of backpack boards for matrix and seven-segment LED displays from Adafruit are typical. </span><span class="koboSpan" id="kobo.196.3">They contain an LED display mounted on a circuit board that also has an I2C LED controller chip on it. </span><span class="koboSpan" id="kobo.196.4">This setup reduces the normally large number of Arduino I/O pins required for controlling an LED display with just the two I2C SDA and SCL pins.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.197.1">These devices (top row of </span><a href="#fig7-1"><span class="koboSpan" id="kobo.198.1">Figure 7-1</span></a><span class="koboSpan" id="kobo.199.1">) are used with a pair of libraries that provide a comprehensive set of functions for displaying graphics and text on Adafruit’s range of LED backpacks. </span><span class="koboSpan" id="kobo.199.2">You can find out more about these colorful and interesting devices here: </span><a href="http://www.adafruit.com/products/902"><span class="koboSpan" id="kobo.200.1">www.adafruit.com/products/902</span></a><span class="koboSpan" id="kobo.201.1">.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.202.1">Once you’ve installed the libraries, all the I2C communication is hidden away, and you can just use high-level commands as illustrated by the following code taken from the libraries’ example sketches:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.203.1"><img alt="image" src="images/p137-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c7-11" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.204.1">DS1307 Real-Time Clock</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.205.1">Another common I2C device is the DS1307 RTC chip. </span><span class="koboSpan" id="kobo.205.2">This chip also has a well-used and reliable Arduino library to simplify it and hide the actual I2C messages. </span><span class="koboSpan" id="kobo.205.3">The library is called </span><i><span class="koboSpan" id="kobo.206.1">RTClib</span></i><span class="koboSpan" id="kobo.207.1"> and can be downloaded from here: </span><a href="https://github.com/adafruit/RTClib"><span class="koboSpan" id="kobo.208.1">https://github.com/adafruit/RTClib</span></a><span class="koboSpan" id="kobo.209.1">.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.210.1">The fragments of code are, again, taken from the examples supplied with the library.</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.211.1"><img alt="image" src="images/p137-02.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.212.1"><img alt="image" src="images/p138-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.213.1">If you want to see the actual I2C code, then you can open the library files and look at how they work. </span><span class="koboSpan" id="kobo.213.2">For example, you’ll find the RTClib library in the files </span><b><span class="koboSpan" id="kobo.214.1">RTClib.h</span></b><span class="koboSpan" id="kobo.215.1"> and </span><b><span class="koboSpan" id="kobo.216.1">RTClib.cpp</span></b><span class="koboSpan" id="kobo.217.1">. </span><span class="koboSpan" id="kobo.217.2">These files are in the folder </span><b><span class="koboSpan" id="kobo.218.1">libraries/RTClib</span></b><span class="koboSpan" id="kobo.219.1">.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.220.1">For example, you can find the function definition for </span><b><span class="koboSpan" id="kobo.221.1">now</span></b><span class="koboSpan" id="kobo.222.1"> in </span><b><span class="koboSpan" id="kobo.223.1">RTClib.cpp</span></b><span class="koboSpan" id="kobo.224.1">:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.225.1"><img alt="image" src="images/p138-02.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.226.1">The values that are read over I2C are in binary-coded decimal (BCD), which must be converted into bytes using the </span><b><span class="koboSpan" id="kobo.227.1">bcd2bin</span></b><span class="koboSpan" id="kobo.228.1"> function in the library.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.229.1">BCD splits a byte into two 4-bit nibbles (yes, really). </span><span class="koboSpan" id="kobo.229.2">Each nibble represents one digit of a two-digit decimal number. </span><span class="koboSpan" id="kobo.229.3">So the number 37 is represented in a BCD byte as 0011 0111. </span><span class="koboSpan" id="kobo.229.4">The first four bits being decimal 3 and the second four bits 7.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.230.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c7-12" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.231.1">Summary</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.232.1">In this chapter, you have learned about I2C and how to use it with an Arduino to communicate with peripherals and other Arduinos.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.233.1">In the next chapter, we examine another type of serial bus interface that is used to communicate with peripherals. </span><span class="koboSpan" id="kobo.233.2">This interface, called </span><i><span class="koboSpan" id="kobo.234.1">1-wire</span></i><span class="koboSpan" id="kobo.235.1">, is not as widely used as I2C, but is used in the popular DS18B20 temperature sensor.</span></span></div>
</div></div></body>
</html>