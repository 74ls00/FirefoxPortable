<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.1//EN' 'http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd'>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Programming Arduino™ Next Steps: Going Further with Sketches</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"></meta>
<link href="stylesheet.css" type="text/css" rel="stylesheet"></link>

<!-- kobo-style -->
<link type="text/css" rel="stylesheet" href="css/kobo.css"></link>
<script type="text/javascript" src="js/kobo.js"></script>
<style type="text/css" id="kobostylehacks">div#book-inner p, div#book-inner div { font-size: 1.0em; } a { color: black; } a:link, a:visited, a:hover, a:active { color: blue; } div#book-inner * { margin-top: 0 !important; margin-bottom: 0 !important;}</style>
</head>
<body><div id="book-columns"><div id="book-inner">
<div class="chapnum" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.1.1">13</span></span></div>
<div class="chaptitle" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.2.1">Digital Signal Processing</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="big"><span class="koboSpan" id="kobo.3.1">The Arduino</span></span><span class="koboSpan" id="kobo.4.1"> is capable of fairly rudimentary signal processing. </span><span class="koboSpan" id="kobo.4.2">This chapter discusses a variety of techniques, from conditioning a signal from an analog input using software rather than external electronics to calculating the relative magnitude of various frequencies in a signal using a Fourier Transform.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.5.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c13-1" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.6.1">Introducing Digital Signal Processing</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.7.1">When you take readings from a sensor, you are measuring a signal. </span><span class="koboSpan" id="kobo.7.2">It is common to visualize that signal as a line (usually wavy) moving from the left of the page to the right over time. </span><span class="koboSpan" id="kobo.7.3">This is how electrical signals are viewed on an oscilloscope. </span><span class="koboSpan" id="kobo.7.4">The </span><i><span class="koboSpan" id="kobo.8.1">y</span></i><span class="koboSpan" id="kobo.9.1">-axis is the </span><i><span class="koboSpan" id="kobo.10.1">amplitude</span></i><span class="koboSpan" id="kobo.11.1"> of the signal (its strength) and the </span><i><span class="koboSpan" id="kobo.12.1">x</span></i><span class="koboSpan" id="kobo.13.1">-axis is time. </span><a href="#fig13-1"><span class="koboSpan" id="kobo.14.1">Figure 13-1</span></a><span class="koboSpan" id="kobo.15.1"> shows a signal in the form of music, captured over a period of just 1/4 of a second using an oscilloscope.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig13-1" class="image"><span><span class="koboSpan" id="kobo.16.1"><img alt="image" src="images/fig13-1.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.17.1">Figure 13-1</span></b><span class="koboSpan" id="kobo.18.1">   </span><i><span class="koboSpan" id="kobo.19.1">A signal from a musical source</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.20.1">You can see some repeating patterns in the signal. </span><span class="koboSpan" id="kobo.20.2">The frequency at which these patterns recur is called the </span><i><span class="koboSpan" id="kobo.21.1">frequency</span></i><span class="koboSpan" id="kobo.22.1">. </span><span class="koboSpan" id="kobo.22.2">This is measured in Hertz (abbreviated to Hz). </span><span class="koboSpan" id="kobo.22.3">A signal of 1 Hz repeats itself once every second. </span><span class="koboSpan" id="kobo.22.4">A signal of 10 Hz, 10 times per second. </span><span class="koboSpan" id="kobo.22.5">Looking at the left of </span><a href="#fig13-1"><span class="koboSpan" id="kobo.23.1">Figure 13-1</span></a><span class="koboSpan" id="kobo.24.1">, you see a signal that repeats itself roughly every 0.6 of a square. </span><span class="koboSpan" id="kobo.24.2">As each square represents 25 milliseconds, with the settings used on the oscilloscope, the frequency of that part of the signal is 1/(0.6×0.025) = 67 Hz. </span><span class="koboSpan" id="kobo.24.3">If you were to zoom in using a shorter time span, you would see that many other sound component frequencies mixed in there as well. </span><span class="koboSpan" id="kobo.24.4">Unless a signal is pure sine wave (like the one shown later in </span><a href="#fig13-5"><span class="koboSpan" id="kobo.25.1">Figure 13-5</span></a><span class="koboSpan" id="kobo.26.1">), then it will always comprise a whole load of frequencies.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.27.1">You could try to capture the signal shown in </span><a href="#fig13-1"><span class="koboSpan" id="kobo.28.1">Figure 13-1</span></a><span class="koboSpan" id="kobo.29.1"> using one of the Arduino’s analog inputs. </span><span class="koboSpan" id="kobo.29.2">This is called </span><i><span class="koboSpan" id="kobo.30.1">digitization</span></i><span class="koboSpan" id="kobo.31.1"> because you are making the analog signal digital. </span><span class="koboSpan" id="kobo.31.2">To do this, you have to be able to take samples fast enough to get a good reproduction of the original signal.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.32.1">The essence of Digital Signal Processing (DSP) is to digitize a signal using an analog-to-digital converter (ADC), manipulate it in some way, and then generate an analog output signal using a digital-to-analog converter (DAC). </span><span class="koboSpan" id="kobo.32.2">Most modern audio equipment, MP3 players, and cell phones use DSP, which provides equalization settings that allow you to control the relative power of the high or low frequencies in a piece of music. </span><span class="koboSpan" id="kobo.32.3">Sometimes, however, you don’t need the output to be a version of the input; you simply need to use DSP techniques to remove unwanted noise from a signal to get more accurate readings from a sensor.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.33.1">In general, Arduinos are not the ideal devices for DSP. </span><span class="koboSpan" id="kobo.33.2">They cannot capture analog signals particularly fast, and their digital output is limited to PWM. </span><span class="koboSpan" id="kobo.33.3">The exception to this is the Arduino Due, which, as well as having lots of ADCs also has a fast processor and two true DACs. </span><span class="koboSpan" id="kobo.33.4">Therefore, the Due’s hardware is sufficiently good enough to stand a fighting chance of digitizing a stereo audio signal and doing something with it.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.34.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c13-2" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.35.1">Averaging Readings</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.36.1">When reading from sensors, you often find that you can get better results by taking a number of readings and then averaging them. </span><span class="koboSpan" id="kobo.36.2">One way to do this is to use a circular buffer (</span><a href="#fig13-2"><span class="koboSpan" id="kobo.37.1">Figure 13-2</span></a><span class="koboSpan" id="kobo.38.1">).</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig13-2" class="image"><span><span class="koboSpan" id="kobo.39.1"><img alt="image" src="images/fig13-2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.40.1">Figure 13-2</span></b><span class="koboSpan" id="kobo.41.1">   </span><i><span class="koboSpan" id="kobo.42.1">A circular buffer</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.43.1">Using a circular buffer arrangement, as each new reading is taken, it is added to the buffer at the current index position. </span><span class="koboSpan" id="kobo.43.2">When the last index position is filled, the index position is set back to zero and the old readings start being overwritten. </span><span class="koboSpan" id="kobo.43.3">In this way, you always keep the last </span><i><span class="koboSpan" id="kobo.44.1">N</span></i><span class="koboSpan" id="kobo.45.1"> readings, where </span><i><span class="koboSpan" id="kobo.46.1">N</span></i><span class="koboSpan" id="kobo.47.1"> is the size of the buffer.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.48.1">The following example code implements a circular buffer:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.49.1"><img alt="image" src="images/p213-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.50.1"><img alt="image" src="images/p214-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.51.1">This approach produces invalid averages until the buffer has been filled. </span><span class="koboSpan" id="kobo.51.2">In practice, this need not be a problem as you can just ensure that you take a buffer full of readings before you start requesting the average.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.52.1">Notice that the </span><b><span class="koboSpan" id="kobo.53.1">average</span></b><span class="koboSpan" id="kobo.54.1"> function uses a </span><b><span class="koboSpan" id="kobo.55.1">long</span></b><span class="koboSpan" id="kobo.56.1"> to contain the sum of the readings. </span><span class="koboSpan" id="kobo.56.2">Using a </span><b><span class="koboSpan" id="kobo.57.1">long</span></b><span class="koboSpan" id="kobo.58.1"> is essential if the buffer is long enough to exceed the maximum </span><b><span class="koboSpan" id="kobo.59.1">int</span></b><span class="koboSpan" id="kobo.60.1"> value of about 32,000. </span><span class="koboSpan" id="kobo.60.2">Note that the return value can still be an </span><b><span class="koboSpan" id="kobo.61.1">int</span></b><span class="koboSpan" id="kobo.62.1"> as the average will be within the range of the individual readings.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.63.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c13-3" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.64.1">An Introduction to Filtering</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.65.1">As I discussed in the section “Introducing Digital Signal Processing,” any signal is usually comprised of a wide range of different component frequencies. </span><span class="koboSpan" id="kobo.65.2">At times, you may want to ignore some of these frequencies, in which case you need to use filtering.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.66.1">The most common type of filtering with an Arduino is probably </span><i><span class="koboSpan" id="kobo.67.1">low-pass filtering</span></i><span class="koboSpan" id="kobo.68.1">. </span><span class="koboSpan" id="kobo.68.2">Say you have a light sensor and you are trying to detect the overall light level and how it changes from minute to minute, for instance, to detect when it is dark enough to turn on a light. </span><span class="koboSpan" id="kobo.68.3">But you want to eliminate higher frequency events such as a hand momentarily passing near the sensor or the sensor being illuminated by artificial light that actually flickers considerably at the line frequency (60 Hz if you live in the United States). </span><span class="koboSpan" id="kobo.68.4">If you are only interested in the very slow-moving part of the signal, then you need a low-pass filter.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.69.1">For the opposite effect, if you want to respond to fast-moving events but ignore the longer trend, you need a </span><i><span class="koboSpan" id="kobo.70.1">high-pass filter</span></i><span class="koboSpan" id="kobo.71.1">.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.72.1">Returning to the line frequency interference problem, if, for example, you are interested in frequencies above and below the 60 Hz noise, then simply cutting off the low frequencies may not be an option. </span><span class="koboSpan" id="kobo.72.2">For that, you may want to use a </span><i><span class="koboSpan" id="kobo.73.1">band stop filter</span></i><span class="koboSpan" id="kobo.74.1"> that just removes the component of the signal at 60 Hz or, more likely, all frequencies from 59 to 61 Hz.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.75.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c13-4" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.76.1">Creating a Simple Low-Pass Filter</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.77.1">Maintaining a buffer of readings is often unnecessary if all you really want to do is smooth out the signal. </span><span class="koboSpan" id="kobo.77.2">Such filtering can be thought of as low-pass filtering because you are rejecting high-frequency rapid signal changing and are interested in the overall trend. </span><span class="koboSpan" id="kobo.77.3">You use filters like this in sensors such as accelerometers that are sensitive to high-frequency changes in the signal that you may not be interested in if you simply want to know the angle something is tilted to.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.78.1">A simple-to-code and useful technique for accomplishing this relies on retaining a kind of running average between readings. </span><span class="koboSpan" id="kobo.78.2">This running average comprises a proportion of the current running average and a proportion of the new reading:</span></span></div>
<div class="noindent1" xmlns="http://www.w3.org/1999/xhtml"><span><i><span class="koboSpan" id="kobo.79.1">smoothedValue</span></i><sub><small><span class="koboSpan" id="kobo.80.1">n</span></small></sub><span class="koboSpan" id="kobo.81.1"> = (</span><i><span class="koboSpan" id="kobo.82.1">alpha</span></i><span class="koboSpan" id="kobo.83.1"> × </span><i><span class="koboSpan" id="kobo.84.1">smoothedValue</span></i><sub><small><span class="koboSpan" id="kobo.85.1">n–1</span></small></sub><span class="koboSpan" id="kobo.86.1">) + ((1 – </span><i><span class="koboSpan" id="kobo.87.1">alpha</span></i><span class="koboSpan" id="kobo.88.1">) × </span><i><span class="koboSpan" id="kobo.89.1">reading</span></i><sub><small><span class="koboSpan" id="kobo.90.1">n</span></small></sub><span class="koboSpan" id="kobo.91.1">)</span></span></div>
<div class="noindent1" xmlns="http://www.w3.org/1999/xhtml"><span><i><span class="koboSpan" id="kobo.92.1">Alpha</span></i><span class="koboSpan" id="kobo.93.1"> is a constant between 0 and 1. </span><span class="koboSpan" id="kobo.93.2">The higher the value of </span><i><span class="koboSpan" id="kobo.94.1">alpha</span></i><span class="koboSpan" id="kobo.95.1">, the greater the smoothing effect.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.96.1">This makes it sound more complicated than it is, however. </span><span class="koboSpan" id="kobo.96.2">The following code shows how easy it is to implement:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.97.1"><img alt="image" src="images/p216-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.98.1">By copying and pasting the output of the Serial Monitor into a spreadsheet and then charting the result, you can see how well the smoothing is performing. </span><a href="#fig13-3"><span class="koboSpan" id="kobo.99.1">Figure 13-3</span></a><span class="koboSpan" id="kobo.100.1"> shows the result of the previous code, with a short wire stuck into the top of A1 to pick up some electrical interference.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig13-3" class="image"><span><span class="koboSpan" id="kobo.101.1"><img alt="image" src="images/fig13-3.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.102.1">Figure 13-3</span></b><span class="koboSpan" id="kobo.103.1">   </span><i><span class="koboSpan" id="kobo.104.1">Plotting smoothed values</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.105.1">You can see how it takes a while for the smoothed value to catch up. </span><span class="koboSpan" id="kobo.105.2">If you were to increase </span><i><span class="koboSpan" id="kobo.106.1">alpha</span></i><span class="koboSpan" id="kobo.107.1"> to, say, 0.95, then the smoothing would be even more pronounced. </span><span class="koboSpan" id="kobo.107.2">Plotting the data written to the Serial Monitor is a great way to make sure the smoothing that you are applying to your signal is what you need.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.108.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c13-5" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.109.1">Arduino Uno DSP</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><a href="#fig13-4"><span class="koboSpan" id="kobo.110.1">Figure 13-4</span></a><span class="koboSpan" id="kobo.111.1"> shows how you can wire up an Arduino so an audio signal is fed into A0 and a PWM (10 kHz) output signal is generated. </span><span class="koboSpan" id="kobo.111.2">I used a smartphone app as the signal generator, and I connected the headphone output of the phone to the Arduino, as shown in </span><a href="#fig13-4"><span class="koboSpan" id="kobo.112.1">Figure 13-4</span></a><span class="koboSpan" id="kobo.113.1">.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig13-4" class="image"><span><span class="koboSpan" id="kobo.114.1"><img alt="image" src="images/fig13-4.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.115.1">Figure 13-4</span></b><span class="koboSpan" id="kobo.116.1">   </span><i><span class="koboSpan" id="kobo.117.1">Using an Arduino Uno for DSP</span></i></span></div>
</div>
<div class="note" xmlns="http://www.w3.org/1999/xhtml"><span><b><i><span class="koboSpan" id="kobo.118.1">CAUTION</span></i></b><span class="koboSpan" id="kobo.119.1">   </span><i><span class="koboSpan" id="kobo.120.1">Be warned: connecting your phone in this way probably voids its warranty and could destroy your phone</span></i><span class="koboSpan" id="kobo.121.1">.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.122.1">The input from the signal generator is biased using C1, R1, and R2; therefore, the oscillation is about the midpoint of 2.5V, so the ADC can read the whole signal. </span><span class="koboSpan" id="kobo.122.2">If these components were not there, the signal would swing below 0V for half its cycle.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.123.1">I used a crude filter comprising R3 and C2 to remove most of the PWM carrier. </span><span class="koboSpan" id="kobo.123.2">The PWM frequency of 10 KHz is unfortunately a bit too close to the signal frequency to remove all the PWM carrier frequency easily.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.124.1">As well as looking at the signal with an oscilloscope, you could also listen to it by attaching an audio amplifier, but if you connect an amplifier, make sure the input is AC coupled.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.125.1">The following sketch uses the TimerOne library to both generate the PWM signal and sample the audio at 10 kHz:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.126.1"><img alt="image" src="images/p218-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><a href="#fig13-5"><span class="koboSpan" id="kobo.127.1">Figure 13-5</span></a><span class="koboSpan" id="kobo.128.1"> shows the input to the Arduino (top trace) and the output from the Arduino (bottom trace) of a 1 kHz signal. </span><span class="koboSpan" id="kobo.128.2">The signal is actually not bad up until you get to 2 to 3 kHz and then it becomes rather triangular, as you would expect with the small number of samples per waveform. </span><span class="koboSpan" id="kobo.128.3">You can see some of the carrier is still there as jaggedness, but overall the shape is not bad. </span><span class="koboSpan" id="kobo.128.4">It is certainly good enough for speech frequencies.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig13-5" class="image"><span><span class="koboSpan" id="kobo.129.1"><img alt="image" src="images/fig13-5.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.130.1">Figure 13-5</span></b><span class="koboSpan" id="kobo.131.1">   </span><i><span class="koboSpan" id="kobo.132.1">Arduino Uno signal reproduction with a signal of 1 kHz</span></i></span></div>
</div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.133.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c13-6" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.134.1">Arduino Due DSP</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.135.1">Now we can carry out the same experiment using an Arduino Due at a much higher sample rate. </span><span class="koboSpan" id="kobo.135.2">The code used for the Uno in the previous section is of no use with the Due, which cannot use the TimerOne library and has a different architecture.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.136.1">The Due analog inputs operate at 3.3V, so be sure to connect the top of R1 to 3.3V and </span><i><span class="koboSpan" id="kobo.137.1">not</span></i><span class="koboSpan" id="kobo.138.1"> 5V. </span><span class="koboSpan" id="kobo.138.2">Because the Due has an analog output, you can dispense with the low-pass R3 and C2 filter and connect the oscilloscope directly to the DAC0 pin. </span><a href="#fig13-6"><span class="koboSpan" id="kobo.139.1">Figure 13-6</span></a><span class="koboSpan" id="kobo.140.1"> shows the connections for the Due.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig13-6" class="image"><span><span class="koboSpan" id="kobo.141.1"><img alt="image" src="images/fig13-6.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.142.1">Figure 13-6</span></b><span class="koboSpan" id="kobo.143.1">   </span><i><span class="koboSpan" id="kobo.144.1">Using an Arduino Due for DSP</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.145.1">The following sketch uses a sample rate of 100 kHz!</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.146.1"><img alt="image" src="images/p220-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.147.1">Unlike the other Arduino boards, the Arduino Due allows the resolution of both the ADC and DAC to be set. </span><span class="koboSpan" id="kobo.147.2">To keep things simple and fast, these are both set to 8 bits.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.148.1">The following line speeds up ADC on the Due by manipulating register values. </span><span class="koboSpan" id="kobo.148.2">Follow the link in the code for more information on this trick.</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.149.1"><img alt="image" src="images/p220-02.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.150.1">The sketch uses the </span><b><span class="koboSpan" id="kobo.151.1">micros</span></b><span class="koboSpan" id="kobo.152.1"> function to control the sample frequency, only running the sampling code when enough microseconds have elapsed.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><a href="#fig13-7"><span class="koboSpan" id="kobo.153.1">Figure 13-7</span></a><span class="koboSpan" id="kobo.154.1"> shows how the setup reproduces a 5 kHz input signal. </span><span class="koboSpan" id="kobo.154.2">You can see the steps in the generated signal corresponding to the 20 samples per waveform you would expect from a 100 kHz sample rate.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig13-7" class="image"><span><span class="koboSpan" id="kobo.155.1"><img alt="image" src="images/fig13-7.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.156.1">Figure 13-7</span></b><span class="koboSpan" id="kobo.157.1">   </span><i><span class="koboSpan" id="kobo.158.1">Arduino Due signal reproduction with a signal of 5 kHz</span></i></span></div>
</div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.159.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c13-7" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.160.1">Filter Code Generation</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.161.1">If you are looking at more advanced filtering, there is a useful online code generator that allows you to design a filter and then cut and paste lines of code that it generates into your Arduino sketch. </span><span class="koboSpan" id="kobo.161.2">You will find this code here: </span><a href="http://www.schwietering.com/jayduino/filtuino/"><span class="koboSpan" id="kobo.162.1">http://www.schwietering.com/jayduino/filtuino/</span></a><span class="koboSpan" id="kobo.163.1">.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.164.1">Frankly, the alternative is whole lot of painful math!</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><a href="#fig13-8"><span class="koboSpan" id="kobo.165.1">Figure 13-8</span></a><span class="koboSpan" id="kobo.166.1"> shows the interface to the filter generator. </span><span class="koboSpan" id="kobo.166.2">The bottom half of the screen shows the generated code, and shortly I will show you how you can incorporate this into an Arduino sketch.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig13-8" class="image"><span><span class="koboSpan" id="kobo.167.1"><img alt="image" src="images/fig13-8.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.168.1">Figure 13-8</span></b><span class="koboSpan" id="kobo.169.1">   </span><i><span class="koboSpan" id="kobo.170.1">Filter code generator for Arduino</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.171.1">You have a bewildering array of options for the type of filter to be generated. </span><span class="koboSpan" id="kobo.171.2">The example shown in </span><a href="#fig13-4"><span class="koboSpan" id="kobo.172.1">Figure 13-4</span></a><span class="koboSpan" id="kobo.173.1"> is a band stop filter designed to reduce the amplitude of the signal at frequencies between 1 kHz and 1.5 kHz. </span><span class="koboSpan" id="kobo.173.2">Starting at the top row, the settings for this are “Butterworth,” “band stop,” and “1st order.” </span><i><span class="koboSpan" id="kobo.174.1">Butterworth</span></i><span class="koboSpan" id="kobo.175.1"> refers to the filter design, from its original analog electronics design (</span><a href="http://en.wikipedia.org/wiki/Butterworth_filter"><span class="koboSpan" id="kobo.176.1">http://en.wikipedia.org/wiki/Butterworth_filter</span></a><span class="koboSpan" id="kobo.177.1">). </span><span class="koboSpan" id="kobo.177.2">The Butterworth is a good all round design and a good default.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.178.1">I also selected the option “1st order.” </span><span class="koboSpan" id="kobo.178.2">Changing this to a higher number will increase both the number of previous samples that need to be stored and also the steepness of the cutoff of the unwanted frequencies. </span><span class="koboSpan" id="kobo.178.3">For this example, “1st order” is fine. </span><span class="koboSpan" id="kobo.178.4">The higher the order, the more calculations to perform and you may find that you need to reduce the sample rate for the Arduino to keep up.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.179.1">Then you see some disabled fields that relate to other types of filter, until you come to “samplerate.” </span><span class="koboSpan" id="kobo.179.2">Samplerate is the frequency at which the data will be sampled and also the frequency at which the generated code will be called to apply the filtering to the signal.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.180.1">Next, I specified the upper and lower frequencies. </span><span class="koboSpan" id="kobo.180.2">You can enter these as either a frequency in Hz or a MIDI note.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.181.1">The “more” section provides a couple more options and even tells you how to set them for best results. </span><span class="koboSpan" id="kobo.181.2">The “output” section allows you to specify the type to use for the array of values that are used to do the filtering. </span><span class="koboSpan" id="kobo.181.3">I set this to “float.” </span><span class="koboSpan" id="kobo.181.4">Finally, I clicked Send to generate the code.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.182.1">To test this, you can modify the “null filter” example that you ran on the Due. </span><span class="koboSpan" id="kobo.182.2">The full sketch can be found in </span><b><span class="koboSpan" id="kobo.183.1">sketch_13_05_band_stop_due</span></b><span class="koboSpan" id="kobo.184.1">.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.185.1">The first step is to copy and paste the generated code into the basic “null filter” example just after the constant definitions. </span><span class="koboSpan" id="kobo.185.2">It is also a good idea to paste the URL from the generator as a comment line, so if you want to go back and modify the filter code, you’ll have the parameters you used last time preset in the user interface. </span><span class="koboSpan" id="kobo.185.3">The generated code encapsulates all the filter code into a class. </span><span class="koboSpan" id="kobo.185.4">You’ll meet classes again in </span><a href="ch15.html"><span class="koboSpan" id="kobo.186.1">Chapter 15</span></a><span class="koboSpan" id="kobo.187.1">. </span><span class="koboSpan" id="kobo.187.2">But, for now, you can treat it as a black box that will do filtering.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.188.1">After the pasted code, you need to add the following line:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.189.1"><img alt="image" src="images/p223-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.190.1">Now you need to modify the </span><b><span class="koboSpan" id="kobo.191.1">loop</span></b><span class="koboSpan" id="kobo.192.1"> function, so that instead of simply outputting the input, the Arduino outputs the filtered value:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.193.1"><img alt="image" src="images/p223-02.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.194.1">Making the filtered signal is as easy as supplying the raw reading from the analog input as argument to the function </span><b><span class="koboSpan" id="kobo.195.1">f.step</span></b><span class="koboSpan" id="kobo.196.1">. </span><span class="koboSpan" id="kobo.196.2">The value returned is the filtered value, which can be converted to an </span><b><span class="koboSpan" id="kobo.197.1">int</span></b><span class="koboSpan" id="kobo.198.1"> before being written by the DAC.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.199.1">Looking at the </span><b><span class="koboSpan" id="kobo.200.1">step</span></b><span class="koboSpan" id="kobo.201.1"> function, you can see that the filter code keeps a history of three previous values along with the new value. </span><span class="koboSpan" id="kobo.201.2">There is some shuffling up of values and then scaling of values by factors to produce a return value. </span><span class="koboSpan" id="kobo.201.3">Isn’t math wonderful?</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><a href="#fig13-9"><span class="koboSpan" id="kobo.202.1">Figure 13-9</span></a><span class="koboSpan" id="kobo.203.1"> shows the result of this filtering. </span><span class="koboSpan" id="kobo.203.2">A signal generator was used to inject different frequency signals and the output amplitude (measured using the oscilloscope) recorded in a spreadsheet and then plotted in a chart.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig13-9" class="image"><span><span class="koboSpan" id="kobo.204.1"><img alt="image" src="images/fig13-9.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.205.1">Figure 13-9</span></b><span class="koboSpan" id="kobo.206.1">   </span><i><span class="koboSpan" id="kobo.207.1">Frequency response of an Arduino band stop filter</span></i></span></div>
</div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.208.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c13-8" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.209.1">The Fourier Transform</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.210.1">The Fourier Transform is a useful tool for analyzing the frequencies in a signal. </span><span class="koboSpan" id="kobo.210.2">As you recall from the introduction to this chapter, signals can be thought of as being made up of varying amounts of sine waves at different frequencies. </span><span class="koboSpan" id="kobo.210.3">You have probably seen frequency analyzer displays on musical equipment or on the visualization utilities in your favorite MP3 playing software. </span><span class="koboSpan" id="kobo.210.4">These analyzers display as bar charts. </span><span class="koboSpan" id="kobo.210.5">The vertical bars represent the relative strengths of different bands of frequencies, with the low-frequency bass notes over on the left and the high-frequency bands on the right.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><a href="#fig13-10"><span class="koboSpan" id="kobo.211.1">Figure 13-10</span></a><span class="koboSpan" id="kobo.212.1"> shows how the same signal can be viewed both as a single wavy line (called the </span><i><span class="koboSpan" id="kobo.213.1">time domain</span></i><span class="koboSpan" id="kobo.214.1">) and a set of strengths of the signal in a set of frequency bands (called the </span><i><span class="koboSpan" id="kobo.215.1">frequency domain</span></i><span class="koboSpan" id="kobo.216.1">).</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig13-10" class="image"><span><span class="koboSpan" id="kobo.217.1"><img alt="image" src="images/fig13-10.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.218.1">Figure 13-10</span></b><span class="koboSpan" id="kobo.219.1">   </span><i><span class="koboSpan" id="kobo.220.1">A signal in time and frequency domains</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.221.1">The algorithm for calculating the frequency domain from time domain signal data is called the </span><i><span class="koboSpan" id="kobo.222.1">Fast Fourier Transform</span></i><span class="koboSpan" id="kobo.223.1"> or </span><i><span class="koboSpan" id="kobo.224.1">FFT</span></i><span class="koboSpan" id="kobo.225.1">. </span><span class="koboSpan" id="kobo.225.2">The calculations involved in FFTs use complex numbers and, unless you are really into math, are not for the faint of heart.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.226.1">Fortunately for us, clever people are often happy to share their code. </span><span class="koboSpan" id="kobo.226.2">You can download a function that will perform the FFT algorithm for you. </span><span class="koboSpan" id="kobo.226.3">The sample code I used is not organized into a library; it is supplied as a C header and C++ implementation file (.h and .cpp, respectively). </span><span class="koboSpan" id="kobo.226.4">To use it, you can just place the two files into your sketch folder. </span><span class="koboSpan" id="kobo.226.5">These are in the sketches that accompany the book, so you do not need to download them. </span><span class="koboSpan" id="kobo.226.6">The code originally appeared in a post on the Arduino Forum (</span><a href="http://forum.arduino.cc/index.php/topic,38153.0.html"><span class="koboSpan" id="kobo.227.1">http://forum.arduino.cc/index.php/topic,38153.0.html</span></a><span class="koboSpan" id="kobo.228.1">). </span><span class="koboSpan" id="kobo.228.2">You can also find the two files, with other examples of the algorithm, at these websites:</span></span></div>
<div class="noindent1" xmlns="http://www.w3.org/1999/xhtml"><span><a href="https://code.google.com/p/arduino-integer-fft/"><span class="koboSpan" id="kobo.229.1">https://code.google.com/p/arduino-integer-fft/</span></a></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><a href="https://github.com/slytown/arduino-spectrum-analyzer/"><span class="koboSpan" id="kobo.230.1">https://github.com/slytown/arduino-spectrum-analyzer/</span></a></span></div>
<div class="indent1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.231.1">The following two examples illustrate how to use code running on an Arduino Uno to sample an audio signal.</span></span></div>
<div id="c13-9" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.232.1">Spectrum Analyzer Example</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.233.1">This example uses an Arduino Uno to make a text-based frequency spectrum display. </span><span class="koboSpan" id="kobo.233.2">You can find the example in </span><b><span class="koboSpan" id="kobo.234.1">sketch_13_06_FFT_Spectrum</span></b><span class="koboSpan" id="kobo.235.1">. </span><span class="koboSpan" id="kobo.235.2">The sketch is a little long to repeat here in full, so I’ve only included snippets. </span><span class="koboSpan" id="kobo.235.3">Load the sketch into your Arduino IDE to follow the discussion.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.236.1">The FFT algorithm uses two arrays of </span><b><span class="koboSpan" id="kobo.237.1">char</span></b><span class="koboSpan" id="kobo.238.1">. </span><span class="koboSpan" id="kobo.238.2">This type is used rather than </span><b><span class="koboSpan" id="kobo.239.1">byte</span></b><span class="koboSpan" id="kobo.240.1">, because in Arduino C, </span><b><span class="koboSpan" id="kobo.241.1">byte</span></b><span class="koboSpan" id="kobo.242.1"> is unsigned, and the signal to be converted is expected to oscillate about a value of 0. </span><span class="koboSpan" id="kobo.242.2">Once the FFT algorithm has been applied, the </span><b><span class="koboSpan" id="kobo.243.1">data</span></b><span class="koboSpan" id="kobo.244.1"> array will contain the strengths of each component frequency band from lower to higher. </span><span class="koboSpan" id="kobo.244.2">The frequency range depends on the sample speed. </span><span class="koboSpan" id="kobo.244.3">This sketch lets the Uno run as fast as possible without any consideration for accuracy and gives a top frequency of about 15 kHz, since there are 63 slots giving evenly spaced frequency bands about 240 Hz apart.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.245.1">To make the analog conversion as fast as possible and get a decent sample rate, use the trick discussed in </span><a href="ch04.html"><span class="koboSpan" id="kobo.246.1">Chapter 4</span></a><span class="koboSpan" id="kobo.247.1"> to increase the speed of the ADC. </span><span class="koboSpan" id="kobo.247.2">This accounts for these two lines in </span><b><span class="koboSpan" id="kobo.248.1">setup</span></b><span class="koboSpan" id="kobo.249.1">.</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.250.1"><img alt="image" src="images/p227-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.251.1">The main </span><b><span class="koboSpan" id="kobo.252.1">loop</span></b><span class="koboSpan" id="kobo.253.1"> doesn’t contain much code:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.254.1"><img alt="image" src="images/p227-02.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.255.1">The function </span><b><span class="koboSpan" id="kobo.256.1">sampleWindowFull</span></b><span class="koboSpan" id="kobo.257.1"> samples a time window of 128 samples worth of data. </span><span class="koboSpan" id="kobo.257.2">I’ll discuss this in a moment. </span><span class="koboSpan" id="kobo.257.3">The FFT algorithm is then applied. </span><span class="koboSpan" id="kobo.257.4">The parameter of 7 is the base 2 logarithm of the number of samples. </span><span class="koboSpan" id="kobo.257.5">This value will always be 7. </span><span class="koboSpan" id="kobo.257.6">The parameter of 0 is an inverse flag, which will also always be set to 0 for false. </span><span class="koboSpan" id="kobo.257.7">After the FFT algorithm has been applied, there is a further step to update the values in the arrays. </span><span class="koboSpan" id="kobo.257.8">Finally </span><b><span class="koboSpan" id="kobo.258.1">showSpectrum</span></b><span class="koboSpan" id="kobo.259.1"> is called to display the frequency data.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.260.1">The function </span><b><span class="koboSpan" id="kobo.261.1">sampleWindowFull</span></b><span class="koboSpan" id="kobo.262.1"> reads 128 analog values and assumes that the signal is biased to 2.5V, so that by subtracting 512 from the reading, the signal will swing both positive and negative. </span><span class="koboSpan" id="kobo.262.2">This is then scaled by the constant </span><b><span class="koboSpan" id="kobo.263.1">GAIN</span></b><span class="koboSpan" id="kobo.264.1"> to add a little amplification for weak signals. </span><span class="koboSpan" id="kobo.264.2">The 10-bit reading is then converted into an 8-bit value to fit into the </span><b><span class="koboSpan" id="kobo.265.1">char</span></b><span class="koboSpan" id="kobo.266.1"> array by dividing it by 4. </span><span class="koboSpan" id="kobo.266.2">The </span><b><span class="koboSpan" id="kobo.267.1">im</span></b><span class="koboSpan" id="kobo.268.1"> array containing the imaginary component of the signal is set to 0. </span><span class="koboSpan" id="kobo.268.2">This is part of the inner workings of the algorithm; if you want to find out more about this, see </span><a href="http://en.wikipedia.org/wiki/Fast_Fourier_transform"><span class="koboSpan" id="kobo.269.1">http://en.wikipedia.org/wiki/Fast_Fourier_transform</span></a><span class="koboSpan" id="kobo.270.1">.</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.271.1"><img alt="image" src="images/p227-03.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.272.1"><img alt="image" src="images/p228-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.273.1">The </span><b><span class="koboSpan" id="kobo.274.1">updateData</span></b><span class="koboSpan" id="kobo.275.1"> function calculates the amplitude of each frequency slot. </span><span class="koboSpan" id="kobo.275.2">The strength of the signal is the hypotenuse of the right-angle triangle whose other sides are the real and imaginary parts of the signal (Pythagoras’s Theorem in action!).</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.276.1"><img alt="image" src="images/p228-02.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.277.1">To display the data, it is written to the Serial Monitor, which places the whole data set on one line, with commas between the values. </span><span class="koboSpan" id="kobo.277.2">The first value is ignored, as this contains the DC component of the signal and is not usually of interest.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.278.1">You could, for example, use the </span><b><span class="koboSpan" id="kobo.279.1">data</span></b><span class="koboSpan" id="kobo.280.1"> array to control the height of graphical bars on an LCD display. </span><span class="koboSpan" id="kobo.280.2">To connect a signal (say, the audio output of an MP3 player), you would need the same type of arrangement as shown previously in </span><a href="#fig13-4"><span class="koboSpan" id="kobo.281.1">Figure 13-4</span></a><span class="koboSpan" id="kobo.282.1"> so the signal is biased around 2.5V.</span></span></div>
<div id="c13-10" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.283.1">Frequency Measurement Example</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.284.1">This second example uses an Arduino Uno to display the approximate frequency of a signal in the Serial Monitor (</span><b><span class="koboSpan" id="kobo.285.1">sketch_13_07_FFT_Freq</span></b><span class="koboSpan" id="kobo.286.1">). </span><span class="koboSpan" id="kobo.286.2">Most of the code is the same as for the previous example. </span><span class="koboSpan" id="kobo.286.3">The main difference is that once the </span><b><span class="koboSpan" id="kobo.287.1">data</span></b><span class="koboSpan" id="kobo.288.1"> array has been calculated, the index position of its highest value is used to calculate an estimate of the frequency. </span><span class="koboSpan" id="kobo.288.2">The </span><b><span class="koboSpan" id="kobo.289.1">loop</span></b><span class="koboSpan" id="kobo.290.1"> then displays this value in the Serial Monitor.</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.291.1"><img alt="image" src="images/p228-03.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.292.1"><img alt="image" src="images/p229-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.293.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c13-11" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.294.1">Summary</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.295.1">DSP is a complex subject, and there are many books devoted just to this topic alone. </span><span class="koboSpan" id="kobo.295.2">This complexity means that, by necessity, I’ve only touched on what are hopefully the more useful and possible techniques that you might try with an Arduino.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.296.1">In the next chapter, we turn our attention to dealing with the problem of wanting to do more than one thing at a time with the Arduino. </span><span class="koboSpan" id="kobo.296.2">This is a particular problem for those of us used to programming larger machines, where multiple simultaneous threads of execution are the norm.</span></span></div>
</div></div></body>
</html>