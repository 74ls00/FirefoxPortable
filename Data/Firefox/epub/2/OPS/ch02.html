<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.1//EN' 'http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd'>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Programming Arduino™ Next Steps: Going Further with Sketches</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"></meta>
<link href="stylesheet.css" type="text/css" rel="stylesheet"></link>

<!-- kobo-style -->
<link type="text/css" rel="stylesheet" href="css/kobo.css"></link>
<script type="text/javascript" src="js/kobo.js"></script>
<style type="text/css" id="kobostylehacks">div#book-inner p, div#book-inner div { font-size: 1.0em; } a { color: black; } a:link, a:visited, a:hover, a:active { color: blue; } div#book-inner * { margin-top: 0 !important; margin-bottom: 0 !important;}</style>
</head>
<body><div id="book-columns"><div id="book-inner">
<div class="chapnum" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.1.1">2</span></span></div>
<div class="chaptitle" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.2.1">Under the Hood</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="big"><span class="koboSpan" id="kobo.3.1">The nice</span></span><span class="koboSpan" id="kobo.4.1"> thing about the Arduino is that a lot of the time, you really do not need to know what goes on behind the scenes when you upload a sketch. </span><span class="koboSpan" id="kobo.4.2">However, as you get more into Arduino and want to push the envelope of what it can do, you need to find out a bit more about what’s going on behind the scenes.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.5.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c2-1" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.6.1">A Brief History of Arduino</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.7.1">The first Arduino board was developed back in 2005 in Italy at the Interaction Design Institute at Ivrea near Turin. </span><span class="koboSpan" id="kobo.7.2">The intention was to design a low-cost and easy-to-use tool for design students to build interactive systems. </span><span class="koboSpan" id="kobo.7.3">The software behind Arduino, which is so much a part of Arduino’s success, is a fork of an open source framework called Wiring. </span><span class="koboSpan" id="kobo.7.4">Wiring was also created by a student at the Institute.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.8.1">The Arduino fork of Wiring is still very close to Wiring, and the Arduino IDE is written in Wiring’s big brother that runs on PCs, Macs, and so on, and is called Processing. </span><span class="koboSpan" id="kobo.8.2">Processing is well worth a look if you have a project where your Arduino needs to talk to a PC over USB or Bluetooth.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.9.1">The Arduino hardware has evolved over the years, but the current Arduino Uno and Leonardo boards retain the same basic shape and sockets as the original.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.10.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c2-2" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.11.1">Anatomy of an Arduino</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><a href="#fig2-1"><span class="koboSpan" id="kobo.12.1">Figure 2-1</span></a><span class="koboSpan" id="kobo.13.1"> shows the anatomy of an Arduino Uno. </span><span class="koboSpan" id="kobo.13.2">The Leonardo is similar but has the USB interface integrated into the main microcontroller chip. </span><span class="koboSpan" id="kobo.13.3">The Due is also similar, but the processor is powered by 3.3V, not 5V.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig2-1" class="image"><span><span class="koboSpan" id="kobo.14.1"><img alt="image" src="images/fig2-1.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.15.1">Figure 2-1</span></b><span class="koboSpan" id="kobo.16.1">   </span><i><span class="koboSpan" id="kobo.17.1">The anatomy of an Arduino Uno</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.18.1">In many ways, the Arduino is really little more than a microcontroller chip with some supporting components. </span><span class="koboSpan" id="kobo.18.2">In fact, it is perfectly possible to build an Arduino on breadboard using the processor chip and a few extra components or to create a PCB for a design that started out using an Arduino as a prototype. </span><span class="koboSpan" id="kobo.18.3">The Arduino boards make things easy, but ultimately any Arduino design can be converted into something that just uses the microcontroller chip and the few components that it really needs. </span><span class="koboSpan" id="kobo.18.4">For example, if the design is only for programming purposes, you may not need a USB interface, as you could program the chip on an Arduino and then transplant the programmed chip into an IC socket on a PCB or to breadboard.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.19.1">Later, we’ll look at how Arduinos can be programmed directly using the ICSP (In Circuit Serial Programming) interface.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.20.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c2-3" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.21.1">AVR Processors</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.22.1">The Arduino family of boards all use microcontrollers made by Atmel. </span><span class="koboSpan" id="kobo.22.2">They all have similar hardware design principals and, with the exception of the microcontroller used in the Due (SAM3X8E ARM Cortex-M3 CPU), they have similar designs.</span></span></div>
<div id="c2-4" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.23.1">ATmega328</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.24.1">The ATmega328 is the microcontroller used in the Arduino Uno and its predecessor the Duemilanove. </span><span class="koboSpan" id="kobo.24.2">In fact, the ATmega168 that was used in the first Arduino boards is basically an ATmega328 but with half of each type of memory.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><a href="#fig2-2"><span class="koboSpan" id="kobo.25.1">Figure 2-2</span></a><span class="koboSpan" id="kobo.26.1"> shows the internals of an ATmega328, taken from its datasheet. </span><span class="koboSpan" id="kobo.26.2">The full datasheet is available from </span><a href="http://www.atmel.com/Images/doc8161.pdf"><span class="koboSpan" id="kobo.27.1">www.atmel.com/Images/doc8161.pdf</span></a><span class="koboSpan" id="kobo.28.1"> and is worth browsing through to learn more about the inner workings of this device.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig2-2" class="image"><span><span class="koboSpan" id="kobo.29.1"><img alt="image" src="images/fig2-2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.30.1">Figure 2-2</span></b><span class="koboSpan" id="kobo.31.1">   </span><i><span class="koboSpan" id="kobo.32.1">The ATmega328</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.33.1">The central processing unit (CPU) is where all the action takes place. </span><span class="koboSpan" id="kobo.33.2">The CPU reads instructions (compiled sketch code) from the flash memory one instruction at a time. </span><span class="koboSpan" id="kobo.33.3">This process is different from a conventional computer where programs are stored on disk and loaded into random access memory (RAM) before they can be run. </span><span class="koboSpan" id="kobo.33.4">Variables that you use in your programs are stored separately in the static RAM (SRAM). </span><span class="koboSpan" id="kobo.33.5">Unlike the flash memory containing the program code, the RAM is volatile and loses its contents when you turn off the power.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.34.1">To allow the nonvolatile storage of data that remains even after the device is powered off, a third type of memory called </span><i><span class="koboSpan" id="kobo.35.1">Electrically Erasable Programmable Read Only Memory (EEPROM)</span></i><span class="koboSpan" id="kobo.36.1"> is used.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.37.1">Another area of interest is the Watchdog Timer and Power Supervision unit. </span><span class="koboSpan" id="kobo.37.2">These give the microcontroller the capability to do a number of things that are normally hidden by the simplified Arduino layer, including clever tricks like putting the chip to sleep and then setting a timer to wake it up periodically. </span><span class="koboSpan" id="kobo.37.3">This trick can be very useful in low current applications, and you can read more on this in </span><a href="ch05.html"><span class="koboSpan" id="kobo.38.1">Chapter 5</span></a><span class="koboSpan" id="kobo.39.1">.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.40.1">The remainder of the block diagram is concerned with the analog-to-digital conversion, the input/output ports, and the three types of serial interfaces supported by the chip: UART - Serial, SPI, and TWI (I2C).</span></span></div>
<div id="c2-5" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.41.1">ATmega32u4</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.42.1">The ATmega32u4 is used in the Arduino Leonardo and also in the LilyPad USB and the Arduinos Micro and Nano. </span><span class="koboSpan" id="kobo.42.2">This processor is similar to the ATmega328, but it is a more modern chip with a few enhancements over the ATmega328:</span></span></div>
<div class="hangbull" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.43.1">•  A built-in USB interface, so there’s no need for extra USB hardware.</span></span></div>
<div class="hangbull" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.44.1">•  More of the pins are PWM capable.</span></span></div>
<div class="hangbull" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.45.1">•  There are two serial ports.</span></span></div>
<div class="hangbull" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.46.1">•  Dedicated pins for I2C (these pins are shared with the analog pins on the Arduino).</span></span></div>
<div class="hangbull" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.47.1">•  There is 0.5kB more SRAM.</span></span></div>
<div class="indent1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.48.1">The version used in the Leonardo is in a surface-mount package, which means it is soldered directly to the Arduino board, whereas the ATmega328 is in a DIL package fitted into an IC socket for the Arduino Uno.</span></span></div>
<div id="c2-6" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.49.1">ATmega2560</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.50.1">The ATmega2560 is used in the Arduino Mega 2560 and the Arduino Mega ADK. </span><span class="koboSpan" id="kobo.50.2">It is no faster than the other ATmega chips, but it does have far more of every type of memory (256k flash, 8k SRAM, and 4k of EEPROM) and many more I/O pins.</span></span></div>
<div id="c2-7" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.51.1">AT91SAM3X8E</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.52.1">This is the chip at the heart of the Arduino Due. </span><span class="koboSpan" id="kobo.52.2">It is much faster than the ATmega chips I have discussed so far, being clocked at 84 MHz, rather than the normal 16 MHz of the ATmegas. </span><span class="koboSpan" id="kobo.52.3">It has 512k of flash and 96KB of SRAM. </span><span class="koboSpan" id="kobo.52.4">The microcontroller does not have any EEPROM. </span><span class="koboSpan" id="kobo.52.5">Instead, to save persistent data, you need to provide your own additional hardware, either in the form of an SD card holder and SD card or flash or EEPROM storage ICs. </span><span class="koboSpan" id="kobo.52.6">The chip itself has many advanced features including two analog outputs that make it ideal for sound generation.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.53.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c2-8" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.54.1">Arduino and Wiring</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.55.1">The Wiring library gives Arduino its easy-to-use functions for controlling the hardware pins; however, the main structural part of the language is all provided by C.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.56.1">Until recently, if you looked in your Arduino installation directory, you could still find a file called </span><b><span class="koboSpan" id="kobo.57.1">WProgram.h</span></b><span class="koboSpan" id="kobo.58.1"> (Wiring Program). </span><span class="koboSpan" id="kobo.58.2">This file has now been replaced by a similar file called </span><b><span class="koboSpan" id="kobo.59.1">Arduino.</span></b><span class="koboSpan" id="kobo.60.1">h that indicates the gradual drift of the Arduino fork away from the original Wiring Project.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.61.1">If you go to your Arduino installation folder, you’ll find a folder called “hardware,” and within that, a folder called “arduino,” and within that, a folder called “cores.” </span><span class="koboSpan" id="kobo.61.2">Note that if you are using a Mac, then you can only get to this folder by right-clicking on your Arduino application, selecting View Package Contents from the menu, and then navigating to the Resources/Java/ folder.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.62.1">Inside the cores folder is another folder called “arduino,” and, in there, you will find a whole load of C header files with the file extension </span><b><span class="koboSpan" id="kobo.63.1">.h</span></b><span class="koboSpan" id="kobo.64.1"> and C++ implementation files with the extension </span><b><span class="koboSpan" id="kobo.65.1">.cpp</span></b><span class="koboSpan" id="kobo.66.1"> (</span><a href="#fig2-3"><span class="koboSpan" id="kobo.67.1">Figure 2-3</span></a><span class="koboSpan" id="kobo.68.1">).</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig2-3" class="image"><span><span class="koboSpan" id="kobo.69.1"><img alt="image" src="images/fig2-3.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.70.1">Figure 2-3</span></b><span class="koboSpan" id="kobo.71.1">   </span><i><span class="koboSpan" id="kobo.72.1">Inside the cores folder</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.73.1">If you open </span><b><span class="koboSpan" id="kobo.74.1">Arduino.h</span></b><span class="koboSpan" id="kobo.75.1"> in an editor, you’ll discover that it consists of many </span><b><span class="koboSpan" id="kobo.76.1">#include</span></b><span class="koboSpan" id="kobo.77.1"> statements. </span><span class="koboSpan" id="kobo.77.2">These pull in definitions from other header files within the cores/arduino folder, so they are included during compilation (converting the sketch into a form suitable for installing into the microcontroller’s flash memory).</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.78.1">You’ll also find constant definitions like this:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.79.1"><img alt="image" src="images/p43-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.80.1">You can think of these as being a bit like variables, so the name </span><b><span class="koboSpan" id="kobo.81.1">HIGH</span></b><span class="koboSpan" id="kobo.82.1"> is given the value 1. </span><span class="koboSpan" id="kobo.82.2">The value is specified as </span><b><span class="koboSpan" id="kobo.83.1">0x1</span></b><span class="koboSpan" id="kobo.84.1"> rather than just 1 because the values are all specified in </span><i><span class="koboSpan" id="kobo.85.1">hexadecimal</span></i><span class="koboSpan" id="kobo.86.1"> (number base 16). </span><span class="koboSpan" id="kobo.86.2">These are not actually variable definitions; they are called </span><i><span class="koboSpan" id="kobo.87.1">C precompiler directives</span></i><span class="koboSpan" id="kobo.88.1">, which means that while your sketch is being turned into something that can be installed into the flash memory on the microcontroller, any instances of the words </span><b><span class="koboSpan" id="kobo.89.1">HIGH</span></b><span class="koboSpan" id="kobo.90.1">, </span><b><span class="koboSpan" id="kobo.91.1">LOW</span></b><span class="koboSpan" id="kobo.92.1">, and so on, are automatically converted into the appropriate number. </span><span class="koboSpan" id="kobo.92.2">This has an advantage over using variables in that no memory has to be reserved for their use.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.93.1">Because these constants are numbers, you could write something like this in your sketch to set pin 5 to be an </span><b><span class="koboSpan" id="kobo.94.1">OUTPUT</span></b><span class="koboSpan" id="kobo.95.1">, but it is better to use the name in case the Arduino developers ever decide to change the constant’s value. </span><span class="koboSpan" id="kobo.95.2">Using a name also makes the code easier to read.</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.96.1"><img alt="image" src="images/p43-02.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.97.1">Also, within </span><b><span class="koboSpan" id="kobo.98.1">arduino.h</span></b><span class="koboSpan" id="kobo.99.1">, you’ll find lots of function “signatures” like this:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.100.1"><img alt="image" src="images/p43-03.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.101.1">These warn the compiler about functions whose actual implementations are to be found elsewhere. </span><span class="koboSpan" id="kobo.101.2">Take the first one as an example. </span><span class="koboSpan" id="kobo.101.3">It specifies the function </span><b><span class="koboSpan" id="kobo.102.1">pinMode</span></b><span class="koboSpan" id="kobo.103.1"> as taking two arguments (that you know to be pin number and mode) that are specified as having a type of </span><b><span class="koboSpan" id="kobo.104.1">uint8_t</span></b><span class="koboSpan" id="kobo.105.1">. </span><span class="koboSpan" id="kobo.105.2">The </span><b><span class="koboSpan" id="kobo.106.1">void</span></b><span class="koboSpan" id="kobo.107.1"> command means the function will not return a value when it is called.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.108.1">You might be wondering why these parameters’ type is specified as </span><b><span class="koboSpan" id="kobo.109.1">uint8_t</span></b><span class="koboSpan" id="kobo.110.1"> rather than </span><b><span class="koboSpan" id="kobo.111.1">int</span></b><span class="koboSpan" id="kobo.112.1">. </span><span class="koboSpan" id="kobo.112.2">Normally when defining which pin to use, you specify an </span><b><span class="koboSpan" id="kobo.113.1">int</span></b><span class="koboSpan" id="kobo.114.1">. </span><span class="koboSpan" id="kobo.114.2">In actual fact, </span><b><span class="koboSpan" id="kobo.115.1">int</span></b><span class="koboSpan" id="kobo.116.1"> is a universal type when writing sketches. </span><span class="koboSpan" id="kobo.116.2">It means users do not need to worry about a large number of possible types that they might have to use. </span><span class="koboSpan" id="kobo.116.3">But in Arduino C, an </span><b><span class="koboSpan" id="kobo.117.1">int</span></b><span class="koboSpan" id="kobo.118.1"> is actually a 16-bit signed number that can represent a number between –32,768 and 32,767. </span><span class="koboSpan" id="kobo.118.2">However, when specifying a pin to use, having negative pin numbers doesn’t make sense and you are very unlikely to ever get a 32,767-pin Arduino.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.119.1">The type </span><b><span class="koboSpan" id="kobo.120.1">uint_8</span></b><span class="koboSpan" id="kobo.121.1"> is a much more precise convention for defining types because an </span><b><span class="koboSpan" id="kobo.122.1">int</span></b><span class="koboSpan" id="kobo.123.1"> in C can be anything between 16 and 64 bits, depending on the C implementation. </span><span class="koboSpan" id="kobo.123.2">The way to read “</span><b><span class="koboSpan" id="kobo.124.1">uint_8</span></b><span class="koboSpan" id="kobo.125.1">” is that the </span><b><span class="koboSpan" id="kobo.126.1">u</span></b><span class="koboSpan" id="kobo.127.1"> is for unsigned, then you have </span><b><span class="koboSpan" id="kobo.128.1">int</span></b><span class="koboSpan" id="kobo.129.1">, and, finally, after the </span><b><span class="koboSpan" id="kobo.130.1">_</span></b><span class="koboSpan" id="kobo.131.1"> you have the number of bits. </span><span class="koboSpan" id="kobo.131.2">So </span><b><span class="koboSpan" id="kobo.132.1">uint_8</span></b><span class="koboSpan" id="kobo.133.1"> is an unsigned 8-bit integer that can represent a number between 0 and 255.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.134.1">You can use these well-defined types within your sketches, and, indeed, some people do. </span><span class="koboSpan" id="kobo.134.2">You have to remember, however, that this makes your code a little less accessible to those who aren’t as experienced in Arduino programming.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.135.1">The reason that using a regular signed 16-bit </span><b><span class="koboSpan" id="kobo.136.1">int</span></b><span class="koboSpan" id="kobo.137.1"> works, rather than, say, a </span><b><span class="koboSpan" id="kobo.138.1">unit_8</span></b><span class="koboSpan" id="kobo.139.1">, is that the compiler automatically performs the conversion for you. </span><span class="koboSpan" id="kobo.139.2">Using </span><b><span class="koboSpan" id="kobo.140.1">int</span></b><span class="koboSpan" id="kobo.141.1"> variables for pin numbers actually wastes memory. </span><span class="koboSpan" id="kobo.141.2">However, you have to balance this against the simplicity and readability of the code. </span><span class="koboSpan" id="kobo.141.3">Generally, in programming it’s better to favor easy-to-read code over minimizing memory usage, unless you know you are doing something complex that is going to push the microcontroller’s limits.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.142.1">It’s a bit like having a truck in which you want to deliver some goods to someone. </span><span class="koboSpan" id="kobo.142.2">If you have a load of stuff to deliver, then you need to think carefully about how to pack the load so it all fits. </span><span class="koboSpan" id="kobo.142.3">If you know that you are only going to use one little corner of the available space, then spending a lot of time minimizing the space it takes is simply unnecessary.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.143.1">Also within the arduino folder, you’ll find a file called </span><b><span class="koboSpan" id="kobo.144.1">main.cpp</span></b><span class="koboSpan" id="kobo.145.1">. </span><span class="koboSpan" id="kobo.145.2">Open this file; you’ll find it pretty interesting.</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.146.1"><img alt="image" src="images/p45-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.147.1">If you have done any C, C++, or Java programming before, you are familiar with the concept of a </span><b><span class="koboSpan" id="kobo.148.1">main</span></b><span class="koboSpan" id="kobo.149.1"> function. </span><span class="koboSpan" id="kobo.149.2">This function runs automatically when the program is run. </span><span class="koboSpan" id="kobo.149.3">Main is the starting point for the whole program. </span><span class="koboSpan" id="kobo.149.4">This is also true of Arduino programs, but it is hidden from the sketch writer, who is instead told to implement two functions—setup and loop—within their sketch.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.150.1">If you look carefully at </span><b><span class="koboSpan" id="kobo.151.1">main.cpp</span></b><span class="koboSpan" id="kobo.152.1">, ignoring the first few lines for now, you can see that it actually calls </span><b><span class="koboSpan" id="kobo.153.1">setup()</span></b><span class="koboSpan" id="kobo.154.1"> and then has a </span><b><span class="koboSpan" id="kobo.155.1">for</span></b><span class="koboSpan" id="kobo.156.1"> loop with no conditions, with the </span><b><span class="koboSpan" id="kobo.157.1">loop</span></b><span class="koboSpan" id="kobo.158.1"> function called inside the loop.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.159.1">The command </span><b><span class="koboSpan" id="kobo.160.1">for(;;)</span></b><span class="koboSpan" id="kobo.161.1"> is simply an ugly way of writing </span><b><span class="koboSpan" id="kobo.162.1">while (true</span></b><span class="koboSpan" id="kobo.163.1">). </span><span class="koboSpan" id="kobo.163.2">Notice that in addition to running the </span><b><span class="koboSpan" id="kobo.164.1">loop</span></b><span class="koboSpan" id="kobo.165.1"> function, there is also an </span><b><span class="koboSpan" id="kobo.166.1">if</span></b><span class="koboSpan" id="kobo.167.1"> command inside the </span><b><span class="koboSpan" id="kobo.168.1">for</span></b><span class="koboSpan" id="kobo.169.1"> that checks for serial messages and services them if they arise.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.170.1">Returning to the top of </span><b><span class="koboSpan" id="kobo.171.1">main.cpp</span></b><span class="koboSpan" id="kobo.172.1">, you can see that the first line is an </span><b><span class="koboSpan" id="kobo.173.1">include</span></b><span class="koboSpan" id="kobo.174.1"> command that pulls in all the definitions in the header file </span><b><span class="koboSpan" id="kobo.175.1">arduino.h</span></b><span class="koboSpan" id="kobo.176.1"> that I mentioned previously.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.177.1">Next, you see the start of the definition of the </span><b><span class="koboSpan" id="kobo.178.1">main</span></b><span class="koboSpan" id="kobo.179.1"> function, which begins by invoking an </span><b><span class="koboSpan" id="kobo.180.1">init()</span></b><span class="koboSpan" id="kobo.181.1"> function. </span><span class="koboSpan" id="kobo.181.2">If you look, you can find what this does in the file </span><b><span class="koboSpan" id="kobo.182.1">wiring.c</span></b><span class="koboSpan" id="kobo.183.1">; it in turn calls a function </span><b><span class="koboSpan" id="kobo.184.1">sei</span></b><span class="koboSpan" id="kobo.185.1">, which enables interrupts.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.186.1">These lines</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.187.1"><img alt="image" src="images/p46-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.188.1">are another example of a C preprocessor directive. </span><span class="koboSpan" id="kobo.188.2">This code is a bit like an </span><b><span class="koboSpan" id="kobo.189.1">if</span></b><span class="koboSpan" id="kobo.190.1"> command that you might use in your sketch, but the decision in the </span><b><span class="koboSpan" id="kobo.191.1">if</span></b><span class="koboSpan" id="kobo.192.1"> is not made when the sketch is actually running on the Arduino. </span><span class="koboSpan" id="kobo.192.2">The </span><b><span class="koboSpan" id="kobo.193.1">#if</span></b><span class="koboSpan" id="kobo.194.1"> is evaluated as the sketch is being compiled. </span><span class="koboSpan" id="kobo.194.2">This directive is a great way to switch chunks in and out of the build, depending on whether they are needed for a particular type of board. </span><span class="koboSpan" id="kobo.194.3">In this case, if the Arduino supports USB, then include the code for attaching the USB (initialize it); otherwise, there is no point in even compiling the code to do that.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.195.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c2-9" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.196.1">From Sketch to Arduino</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.197.1">Now that you have a basic understanding of where all the magic code comes from when you write a simple Arduino sketch, let’s look at exactly how that code gets into the flash memory of an Arduino board’s microcontroller when you click the Upload button in the Arduino IDE.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><a href="#fig2-4"><span class="koboSpan" id="kobo.198.1">Figure 2-4</span></a><span class="koboSpan" id="kobo.199.1"> shows what happens when you click the Upload button.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig2-4" class="image"><span><span class="koboSpan" id="kobo.200.1"><img alt="image" src="images/fig2-4.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.201.1">Figure 2-4</span></b><span class="koboSpan" id="kobo.202.1">   </span><i><span class="koboSpan" id="kobo.203.1">The Arduino toolchain</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.204.1">Arduino sketches are held in a text file with the </span><b><span class="koboSpan" id="kobo.205.1">.ino</span></b><span class="koboSpan" id="kobo.206.1"> extension, in a folder of the same name but without the extension.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.207.1">What actually happens is that the Arduino IDE controls a number of utility programs that do all the actual work. </span><span class="koboSpan" id="kobo.207.2">First, a part of the Arduino IDE that (for want of a better name), I have named the </span><i><span class="koboSpan" id="kobo.208.1">Arduino IDE preprocessor</span></i><span class="koboSpan" id="kobo.209.1"> assembles the files provided as part of the sketch. </span><span class="koboSpan" id="kobo.209.2">Note that normally only one file is in the sketch folder; however, you can place other files in the folder if you wish, but you need to use a separate editor to create them.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.210.1">If you have other files in the folder, they will be included in this build process. </span><span class="koboSpan" id="kobo.210.2">C and C++ files are compiled separately. </span><span class="koboSpan" id="kobo.210.3">A line to include </span><b><span class="koboSpan" id="kobo.211.1">arduino.h</span></b><span class="koboSpan" id="kobo.212.1"> is added to the top of the main sketch file.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.213.1">As there are many different types of Arduino boards that use different microcontroller chips that have different pin names, the Arduino IDE must use the right pin definitions for the board. </span><span class="koboSpan" id="kobo.213.2">If you look in the hard-ware/arduino/variants folder, you’ll find a folder for each type of Arduino board, and inside each folder, you’ll see a file called </span><b><span class="koboSpan" id="kobo.214.1">pins_arduino.h</span></b><span class="koboSpan" id="kobo.215.1">. </span><span class="koboSpan" id="kobo.215.2">This file contains constants for the pin names for that platform.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.216.1">When everything has been combined, the next step is to invoke the GCC compiler. </span><span class="koboSpan" id="kobo.216.2">This compiler is an open source C++ compiler that is bundled as part of the Arduino distribution. </span><span class="koboSpan" id="kobo.216.3">It takes the sketch, header, and C implementation source code files and converts them into something that can be run on an Arduino. </span><span class="koboSpan" id="kobo.216.4">It does this in a number of steps:</span></span></div>
<div class="numlist" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.217.1">1.  The preprocessor interprets all the </span><b><span class="koboSpan" id="kobo.218.1">#if</span></b><span class="koboSpan" id="kobo.219.1"> and </span><b><span class="koboSpan" id="kobo.220.1">#define</span></b><span class="koboSpan" id="kobo.221.1"> commands and determines what actually goes into the build.</span></span></div>
<div class="numlist" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.222.1">2.  Next, the code is compiled and linked into a single executable file for the type of processor used by the board.</span></span></div>
<div class="numlist" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.223.1">3.  After the compiler has finished its work, another piece of open source software called </span><i><span class="koboSpan" id="kobo.224.1">avrdude</span></i><span class="koboSpan" id="kobo.225.1"> actually sends the executable code, saved as a hexadecimal representation of the binary, to the board over the USB serial interface.</span></span></div>
<div class="indent1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.226.1">We are now in the Arduino’s realm. </span><span class="koboSpan" id="kobo.226.2">The Arduino has a small resident program installed on every microcontroller that is included with its board. </span><span class="koboSpan" id="kobo.226.3">This program is called a </span><i><span class="koboSpan" id="kobo.227.1">bootloader</span></i><span class="koboSpan" id="kobo.228.1">. </span><span class="koboSpan" id="kobo.228.2">The bootloader actually runs very briefly every time an Arduino is reset. </span><span class="koboSpan" id="kobo.228.3">This is why when serial communication starts to an Arduino Uno, the hardware serial link forces a reset to give the bootloader chance to check for any incoming sketches.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.229.1">If there is a sketch, then the Arduino effectively programs itself by unpacking the hexadecimal representation of the program into binary. </span><span class="koboSpan" id="kobo.229.2">It then stores the sketch in the flash memory. </span><span class="koboSpan" id="kobo.229.3">The next time that the Arduino restarts, after the usual bootloader check for a new sketch, the program that was stored in flash is automatically run.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.230.1">You might wonder why the host computer cannot program the microcontroller directly rather than taking this convoluted path. </span><span class="koboSpan" id="kobo.230.2">The reason is that programming a microcontroller requires special hardware that uses a different interface to the Arduino board (ever wondered what the little six-pin header was for?). </span><span class="koboSpan" id="kobo.230.3">By using a bootloader that can listen on a serial port, you can program the Arduino though USB without having to use special programming hardware.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.231.1">However, if you do have such a programmer, such as the AVRISPv2, AVRDragon, or the USBtinyISP, then you can program the Arduino directly through such a programmer, bypassing the bootloader entirely. </span><span class="koboSpan" id="kobo.231.2">In fact, as you shall see later in this chapter, you can also use a second Arduino as a programmer.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.232.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c2-10" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.233.1">AVR Studio</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.234.1">Certain hard-bitten electronic engineers can be a bit snotty about Arduino. </span><span class="koboSpan" id="kobo.234.2">They might tell you that it doesn’t have any technical advantages over using the tools provided by Atmel for programming the whole family of AVR microcontrollers. </span><span class="koboSpan" id="kobo.234.3">While technically true, this misses the point of Arduino, which is to demystify the whole process of using a microcontroller and to wrestle it from the control of such experts. </span><span class="koboSpan" id="kobo.234.4">This does mean that some of the things us Arduino aficionados do could be considered a bit amateurish, but I say so what!</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.235.1">AVR Studio is the manufacturer’s proprietary software for programming the microcontrollers used in Arduinos. </span><span class="koboSpan" id="kobo.235.2">You can use it to program the Arduino itself, rather than using the Arduino IDE. </span><span class="koboSpan" id="kobo.235.3">If you do, however, you will have to accept the following:</span></span></div>
<div class="hangbull" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.236.1">•  A Windows-only environment</span></span></div>
<div class="hangbull" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.237.1">•  Using a hardware programmer rather than USB</span></span></div>
<div class="hangbull" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.238.1">•  A more complex environment</span></span></div>
<div class="indent1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.239.1">Perhaps this is the point at which you might want to consider why you might want to do this. </span><span class="koboSpan" id="kobo.239.2">Here are some good reasons:</span></span></div>
<div class="hangbull" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.240.1">•  You want to get rid of the bootloader (it uses 500 bytes on a Uno) because either you are short of flash memory or you want a quicker start after reset.</span></span></div>
<div class="hangbull" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.241.1">•  You want to target other microcontrollers than those used in standard Arduinos, such as the less expensive and smaller ATtiny family.</span></span></div>
<div class="hangbull" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.242.1">•  You just want to learn something new.</span></span></div>
<div class="indent1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.243.1">The Arduino boards all come with a six-pin header that can be used to program the Arduino directly using AVR Studio. </span><span class="koboSpan" id="kobo.243.2">In fact, some boards come with two six-pin headers: one for the main processor and one for the USB interface, so be careful to connect to the right one.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><a href="#fig2-5"><span class="koboSpan" id="kobo.244.1">Figure 2-5</span></a><span class="koboSpan" id="kobo.245.1"> shows AVR Studio 4 in action.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig2-5" class="image"><span><span class="koboSpan" id="kobo.246.1"><img alt="image" src="images/fig2-5.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.247.1">Figure 2-5</span></b><span class="koboSpan" id="kobo.248.1">   </span><i><span class="koboSpan" id="kobo.249.1">AVR Studio</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.250.1">It is beyond the scope of this book to teach AVR Studio. </span><span class="koboSpan" id="kobo.250.2">However, as you can see from </span><a href="#fig2-5"><span class="koboSpan" id="kobo.251.1">Figure 2-5</span></a><span class="koboSpan" id="kobo.252.1">, the Blink sketch does not get any longer, but it certainly looks more complicated! </span><span class="koboSpan" id="kobo.252.2">It will also compile into a tiny amount of flash memory compared with its Arduino counterpart.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><a href="#fig2-6"><span class="koboSpan" id="kobo.253.1">Figure 2-6</span></a><span class="koboSpan" id="kobo.254.1"> shows an Arduino connected to an AVR Dragon programmer. </span><span class="koboSpan" id="kobo.254.2">This programmer is particularly powerful and flexible, and it allows you to debug and single-step through programs actually running on the ATmega chip.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig2-6" class="image"><span><span class="koboSpan" id="kobo.255.1"><img alt="image" src="images/fig2-6.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.256.1">Figure 2-6</span></b><span class="koboSpan" id="kobo.257.1">   </span><i><span class="koboSpan" id="kobo.258.1">An Arduino connected to an AVR Dragon programmer</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.259.1">In </span><a href="ch04.html"><span class="koboSpan" id="kobo.260.1">Chapter 4</span></a><span class="koboSpan" id="kobo.261.1">, we look at the kind of direct port manipulation that is going on in </span><a href="#fig2-5"><span class="koboSpan" id="kobo.262.1">Figure 2-5</span></a><span class="koboSpan" id="kobo.263.1"> as a way to improve I/O performance without having to abandon the Arduino IDE.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.264.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c2-11" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.265.1">Installing a Bootloader</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.266.1">You might want to install the Arduino bootloader onto an Arduino board for several reasons. </span><span class="koboSpan" id="kobo.266.2">You may have damaged the removable ATmega328 on an Arduino Uno and be replacing the chip with a new ATmega328 (bought without the bootloader). </span><span class="koboSpan" id="kobo.266.3">Alternatively, you may be moving an Arduino prototype off-board, by taking the ATmega328 off the Arduino board and fitting it to a custom board of your own design.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.267.1">Whatever the reason, you can add a bootloader to a blank ATmega328, either by using one of the programmers mentioned in the previous section or by using one Arduino to program a second.</span></span></div>
<div id="c2-12" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.268.1">Burning a Bootloader with AVR Studio and a Programmer</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.269.1">The Arduino installation folder contains bootloader hex files that can be flashed onto an ATmega328 using AVR Studio. </span><span class="koboSpan" id="kobo.269.2">You will find these files in the hardware/arduino/bootloaders folder. </span><span class="koboSpan" id="kobo.269.3">There, you will find hex files for all sorts of different hardware. </span><span class="koboSpan" id="kobo.269.4">If want to install a bootloader for an Uno, use the </span><b><span class="koboSpan" id="kobo.270.1">optiboot_atmega328.hex</span></b><span class="koboSpan" id="kobo.271.1"> file in the optiboot folder (</span><a href="#fig2-7"><span class="koboSpan" id="kobo.272.1">Figure 2-7</span></a><span class="koboSpan" id="kobo.273.1">).</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig2-7" class="image"><span><span class="koboSpan" id="kobo.274.1"><img alt="image" src="images/fig2-7.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.275.1">Figure 2-7</span></b><span class="koboSpan" id="kobo.276.1">   </span><i><span class="koboSpan" id="kobo.277.1">Burning an Uno bootloader in AVR Studio 4</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.278.1">First, a word of warning. </span><span class="koboSpan" id="kobo.278.2">If you are going to try this, then be aware that there is a chance you will “brick” your processor chip. </span><span class="koboSpan" id="kobo.278.3">These chips have what are called “fuses” that can be set and sometimes cannot be reset. </span><span class="koboSpan" id="kobo.278.4">They are designed this way for proprietary reasons, when you want to prevent reprogramming for commercial reasons. </span><span class="koboSpan" id="kobo.278.5">Check carefully that the fuses are set correctly for the Arduino board you are programming before you take the plunge, and accept that you may incur a loss. </span><span class="koboSpan" id="kobo.278.6">The Arduino forum at </span><a href="http://www.arduino.cc/forum"><span class="koboSpan" id="kobo.279.1">www.arduino.cc/forum</span></a><span class="koboSpan" id="kobo.280.1"> includes many threads on this topic, along with “gotchas” to avoid.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.281.1">To burn the bootloader using AVR Studio and an AVR Dragon, connect the programmer to the Arduino ISP header pins (see </span><a href="#fig2-6"><span class="koboSpan" id="kobo.282.1">Figure 2-6</span></a><span class="koboSpan" id="kobo.283.1"> earlier in the chapter). </span><span class="koboSpan" id="kobo.283.2">Note that an Arduino Uno actually has two sets of ISP header pins; the other sets are for flashing the USB interface.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.284.1">From the Tools menu, select the Program AVR option and then connect to the ATmega328 on the Arduino. </span><span class="koboSpan" id="kobo.284.2">Then in the Flash section, browse to the correct hex file and then click Program.</span></span></div>
<div id="c2-13" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.285.1">Burning a Bootloader with the Arduino IDE and a Second Arduino</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.286.1">Flashing one Arduino with a new bootloader from another Arduino is remarkably easy. </span><span class="koboSpan" id="kobo.286.2">It is certainly easier and less risky than using AVR Studio. </span><span class="koboSpan" id="kobo.286.3">The Arduino IDE includes an option to do this. </span><span class="koboSpan" id="kobo.286.4">Here’s all you need to get started:</span></span></div>
<div class="hangbull" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.287.1">•  Two Arduino Unos</span></span></div>
<div class="hangbull" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.288.1">•  Six male-to-male jumper leads (or solid core wire)</span></span></div>
<div class="hangbull" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.289.1">•  One short length of solid core wire</span></span></div>
<div class="hangbull" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.290.1">•  A 10µF 10V (100µF will also work) capacitor</span></span></div>
<div class="indent1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.291.1">You first need to make the connections listed in </span><a href="#tab2-1"><span class="koboSpan" id="kobo.292.1">Table 2-1</span></a><span class="koboSpan" id="kobo.293.1">.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="tab2-1" class="imagex"><span><span class="koboSpan" id="kobo.294.1"><img alt="image" src="images/tab2-1.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.295.1">Table 2-1</span></b><span class="koboSpan" id="kobo.296.1">   </span><i><span class="koboSpan" id="kobo.297.1">Arduino to Arduino Programming Connections</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.298.1">You also need to attach a 10µF capacitor between Reset and GND on the target Arduino (the one being programmed). </span><span class="koboSpan" id="kobo.298.2">The capacitor will have a longer positive lead, which should go to Reset.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><a href="#fig2-8"><span class="koboSpan" id="kobo.299.1">Figure 2-8</span></a><span class="koboSpan" id="kobo.300.1"> shows the connected Arduinos. </span><span class="koboSpan" id="kobo.300.2">The Arduino on the right of </span><a href="#fig2-8"><span class="koboSpan" id="kobo.301.1">Figure 2-8</span></a><span class="koboSpan" id="kobo.302.1"> is the one doing the programming. </span><span class="koboSpan" id="kobo.302.2">Notice how solid-core wire is used for the connection between pin 10 on the programming Arduino and Reset on the target Arduino. </span><span class="koboSpan" id="kobo.302.3">This is so that both the wire and the positive lead of the capacitor will fit in the Reset socket.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig2-8" class="image"><span><span class="koboSpan" id="kobo.303.1"><img alt="image" src="images/fig2-8.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.304.1">Figure 2-8</span></b><span class="koboSpan" id="kobo.305.1">   </span><i><span class="koboSpan" id="kobo.306.1">Arduino to Arduino Flashing</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.307.1">Note that the Arduino doing the programming powers the Arduino being programmed, so only the programming Arduino needs to be connected to your computer by USB.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.308.1">The Arduino that is going to do the programming needs to have a sketch installed on it. </span><span class="koboSpan" id="kobo.308.2">You will find this under File | Examples. </span><span class="koboSpan" id="kobo.308.3">The sketch is called </span><b><span class="koboSpan" id="kobo.309.1">ArduinoISP</span></b><span class="koboSpan" id="kobo.310.1"> and is in the top section of the Examples.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.311.1">Select the board type and port in the usual way and upload the </span><b><span class="koboSpan" id="kobo.312.1">ArduinoISP</span></b><span class="koboSpan" id="kobo.313.1"> sketch onto the Arduino doing the programming. </span><span class="koboSpan" id="kobo.313.2">Now from the Tools menu, select the Programmer submenu and select the Arduino as ISP option.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.314.1">Finally, select the Burn Bootloader option from the Tools menu. </span><span class="koboSpan" id="kobo.314.2">The process takes a minute or two, during which the Rx and Tx LEDs should flicker on the programming Arduino and the “L” LED flicker on the target Arduino.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.315.1">When the process finishes, that’s it—the microcontroller on the target Arduino has a new bootloader installed.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.316.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c2-14" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.317.1">Summary</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.318.1">In this chapter, we looked more closely at what exactly the Arduino is and how it works. </span><span class="koboSpan" id="kobo.318.2">In particular, I showed you what is hidden by the Arduino environment.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.319.1">In the next chapter, we look at using interrupts and at how to make the Arduino respond to external timer-triggered events using interrupts.</span></span></div>
</div></div></body>
</html>