<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.1//EN' 'http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd'>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Programming Arduino™ Next Steps: Going Further with Sketches</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"></meta>
<link href="stylesheet.css" type="text/css" rel="stylesheet"></link>

<!-- kobo-style -->
<link type="text/css" rel="stylesheet" href="css/kobo.css"></link>
<script type="text/javascript" src="js/kobo.js"></script>
<style type="text/css" id="kobostylehacks">div#book-inner p, div#book-inner div { font-size: 1.0em; } a { color: black; } a:link, a:visited, a:hover, a:active { color: blue; } div#book-inner * { margin-top: 0 !important; margin-bottom: 0 !important;}</style>
</head>
<body><div id="book-columns"><div id="book-inner">
<div class="chapnum" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.1.1">9</span></span></div>
<div class="chaptitle" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.2.1">Interfacing with SPI Devices</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="big"><span class="koboSpan" id="kobo.3.1">The Serial</span></span><span class="koboSpan" id="kobo.4.1"> Peripheral Interface (SPI) bus is yet another serial bus standard that you can use to connect peripherals to your Arduino. </span><span class="koboSpan" id="kobo.4.2">It is fast but uses four pins compared with the two that I2C uses. </span><span class="koboSpan" id="kobo.4.3">SPI is not actually a true bus, as the fourth pin is a Save Select (SS) pin. </span><span class="koboSpan" id="kobo.4.4">One Arduino pin must be used for SS for each peripheral on the bus. </span><span class="koboSpan" id="kobo.4.5">This setup effectively addresses the right peripheral on the bus by turning all the other peripherals off.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.5.1">A wide range of SPI devices are available, including many of the same type of devices available for I2C. </span><span class="koboSpan" id="kobo.5.2">It is not uncommon for peripherals to have both I2C and SPI interfaces.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.6.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c9-1" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.7.1">Bit Manipulation</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.8.1">SPI interfacing tends to involve a lot of bit manipulation to get data on and off the bus. </span><span class="koboSpan" id="kobo.8.2">The first example project (using an MCP3008 ADC IC), in particular, requires a good understanding of how to shuffle bits along and mask the ones you don’t want in order to extract an integer value for the analog reading. </span><span class="koboSpan" id="kobo.8.3">For this reason, before I go any further into the workings of SPI, I’ll make a diversion to explain, in more detail, bit manipulation.</span></span></div>
<div id="c9-2" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.9.1">Binary and Hex</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.10.1">You first met the concept of bits and bytes back in </span><a href="ch04.html"><span class="koboSpan" id="kobo.11.1">Chapter 4</span></a><span class="koboSpan" id="kobo.12.1"> (see </span><a href="ch04.html#fig4-2"><span class="koboSpan" id="kobo.13.1">Figure 4-2</span></a><span class="koboSpan" id="kobo.14.1">). </span><span class="koboSpan" id="kobo.14.2">When you are manipulating bits in a byte or word (two bytes), you can use their decimal values, but converting between binary and decimal is not that easy to do in your head. </span><span class="koboSpan" id="kobo.14.3">For this reason, values are often expressed as binary constants in Arduino C, which you can do using the special syntax shown in this example:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.15.1"><img alt="image" src="images/p150-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.16.1">In the first line, a byte with the decimal value of 3 (2 + 1) is defined. </span><span class="koboSpan" id="kobo.16.2">The leading zeros are optional, but providing them serves as a handy reminder that 8 bits are available.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.17.1">The second example uses an </span><b><span class="koboSpan" id="kobo.18.1">int</span></b><span class="koboSpan" id="kobo.19.1"> to hold 16 bits. </span><span class="koboSpan" id="kobo.19.2">The qualifier </span><b><span class="koboSpan" id="kobo.20.1">unsigned</span></b><span class="koboSpan" id="kobo.21.1"> is placed in front of </span><b><span class="koboSpan" id="kobo.22.1">int</span></b><span class="koboSpan" id="kobo.23.1"> to indicate that the variable should only be used to represent positive numbers. </span><span class="koboSpan" id="kobo.23.2">This qualifier only really matters if you are using </span><b><span class="koboSpan" id="kobo.24.1">+</span></b><span class="koboSpan" id="kobo.25.1">, </span><b><span class="koboSpan" id="kobo.26.1">–</span></b><span class="koboSpan" id="kobo.27.1">, </span><b><span class="koboSpan" id="kobo.28.1">*</span></b><span class="koboSpan" id="kobo.29.1">, and so on, with the variable, which you should not do if you are using it for bit manipulation. </span><span class="koboSpan" id="kobo.29.2">But including the word </span><b><span class="koboSpan" id="kobo.30.1">unsigned</span></b><span class="koboSpan" id="kobo.31.1"> is good practice.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.32.1">When you get to 16 bits, the binary representation starts to look a bit long and unwieldy. </span><span class="koboSpan" id="kobo.32.2">For this reason, people often use a notation called </span><i><span class="koboSpan" id="kobo.33.1">hexadecimal</span></i><span class="koboSpan" id="kobo.34.1">, or more commonly just </span><i><span class="koboSpan" id="kobo.35.1">hex</span></i><span class="koboSpan" id="kobo.36.1">, to represent longer binary numbers.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.37.1">Hex is number base 16, which means you have the usual digits 0 to 9 but also the letters A to F that represent the decimal values 10 to 15. </span><span class="koboSpan" id="kobo.37.2">That way, each four bits of a number can be represented in a single digit. </span><a href="#tab9-1"><span class="koboSpan" id="kobo.38.1">Table 9-1</span></a><span class="koboSpan" id="kobo.39.1"> shows the decimal, binary, and hexadecimal representations of the numbers 0 to 15 (decimal).</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="tab9-1" class="imagex"><span><span class="koboSpan" id="kobo.40.1"><img alt="image" src="images/tab9-1.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.41.1">Table 9-1</span></b><span class="koboSpan" id="kobo.42.1">   </span><i><span class="koboSpan" id="kobo.43.1">Binary and Hexadecimal Numbers</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.44.1">Hex constants have a special notation similar to that of binary:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.45.1"><img alt="image" src="images/p150-02.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.46.1">You’ll see this notation used outside of C, in documentation, to make it clear that the number is hex and not decimal.</span></span></div>
<div id="c9-3" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.47.1">Masking Bits</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.48.1">A common problem when you receive data from a peripheral using any kind of connection is that the data arrives packed into bytes and not all of the bytes are needed. </span><span class="koboSpan" id="kobo.48.2">Peripheral designers often fit as much information as they can into as few bits as possible, speeding up communication, but often at the expense of making the devices more difficult to program.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.49.1">The process of “masking” bits allows you to disregard some of the data in a byte or larger data structure. </span><a href="#fig9-1"><span class="koboSpan" id="kobo.50.1">Figure 9-1</span></a><span class="koboSpan" id="kobo.51.1"> shows how a byte containing multiple data can be masked to produce a number from the least significant three bits of the byte.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig9-1" class="image"><span><span class="koboSpan" id="kobo.52.1"><img alt="image" src="images/fig9-1.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.53.1">Figure 9-1</span></b><span class="koboSpan" id="kobo.54.1">   </span><i><span class="koboSpan" id="kobo.55.1">Masking bits</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.56.1">You’ll come across the phrases “least significant” and “most significant” to describe binary numbers. </span><span class="koboSpan" id="kobo.56.2">In binary written in the normal mathematical way, the most significant bit is the leftmost bit and the least significant bit is the rightmost. </span><span class="koboSpan" id="kobo.56.3">After all, the rightmost is only worth 1 or 0. </span><span class="koboSpan" id="kobo.56.4">You’ll also see the terms </span><i><span class="koboSpan" id="kobo.57.1">most significant bit (MSB)</span></i><span class="koboSpan" id="kobo.58.1"> and </span><i><span class="koboSpan" id="kobo.59.1">least significant bit (LSB)</span></i><span class="koboSpan" id="kobo.60.1">. </span><span class="koboSpan" id="kobo.60.2">The least significant bit is also sometimes referred to as </span><i><span class="koboSpan" id="kobo.61.1">bit 0</span></i><span class="koboSpan" id="kobo.62.1">, bit 1 being the next most significant bit and so on.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.63.1">In the example shown in </span><a href="#fig9-1"><span class="koboSpan" id="kobo.64.1">Figure 9-1</span></a><span class="koboSpan" id="kobo.65.1">, the data byte has some values at the most significant end that we are not interested in and only three bits at the least significant end that we want to extract as a number. </span><span class="koboSpan" id="kobo.65.2">You do this by “anding” the data with a mask value that has the three bits you’re interested in set to 1. </span><span class="koboSpan" id="kobo.65.3">Then you “and” together two bytes; each of the bits is, in turn, “anded” with each other to build a result. </span><span class="koboSpan" id="kobo.65.4">The result of “anding” two bits is only 1, if both the bits are 1.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.66.1">Here’s how the example looks in Arduino C using the </span><b><span class="koboSpan" id="kobo.67.1">&amp;</span></b><span class="koboSpan" id="kobo.68.1"> operator. </span><span class="koboSpan" id="kobo.68.2">Note that bitwise </span><b><span class="koboSpan" id="kobo.69.1">and</span></b><span class="koboSpan" id="kobo.70.1"> uses the single </span><b><span class="koboSpan" id="kobo.71.1">&amp;</span></b><span class="koboSpan" id="kobo.72.1"> character rather than the </span><b><span class="koboSpan" id="kobo.73.1">&amp;&amp;</span></b><span class="koboSpan" id="kobo.74.1"> used in logical </span><b><span class="koboSpan" id="kobo.75.1">and</span></b><span class="koboSpan" id="kobo.76.1">.</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.77.1"><img alt="image" src="images/p152-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.78.1">At the end, the variable “result” contains the value 5 (decimal).</span></span></div>
<div id="c9-4" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.79.1">Shifting Bits</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.80.1">Another thing you will find with received data is that having masked the bits you want, those bits are not all at the least significant end of the byte.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.81.1">For example, if the value of interest in the data used in </span><a href="#fig9-1"><span class="koboSpan" id="kobo.82.1">Figure 9-1</span></a><span class="koboSpan" id="kobo.83.1"> was between bits 5 and 3 (see </span><a href="#fig9-2"><span class="koboSpan" id="kobo.84.1">Figure 9-2</span></a><span class="koboSpan" id="kobo.85.1">), you need to first mask the bits of interest, as you did in the previous example, and then sift the bits three places to the right.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig9-2" class="image"><span><span class="koboSpan" id="kobo.86.1"><img alt="image" src="images/fig9-2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.87.1">Figure 9-2</span></b><span class="koboSpan" id="kobo.88.1">   </span><i><span class="koboSpan" id="kobo.89.1">Masking and shifting bits</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.90.1">You use the C operator </span><b><span class="koboSpan" id="kobo.91.1">&gt;&gt;</span></b><span class="koboSpan" id="kobo.92.1"> to shift bits to the right and the number following the </span><b><span class="koboSpan" id="kobo.93.1">&gt;&gt;</span></b><span class="koboSpan" id="kobo.94.1"> is the number of bit positions to shift the bits. </span><span class="koboSpan" id="kobo.94.2">This may result in some bits being shifted off the end of the byte. </span><span class="koboSpan" id="kobo.94.3">Here’s this example written in C:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.95.1"><img alt="image" src="images/p153-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.96.1">What if you need to take two 8-bit bytes and assemble them into a single 16-bit </span><b><span class="koboSpan" id="kobo.97.1">int</span></b><span class="koboSpan" id="kobo.98.1">? </span><span class="koboSpan" id="kobo.98.2">You can accomplish this by first shifting the bits of one byte (the most significant byte) to one end of the </span><b><span class="koboSpan" id="kobo.99.1">int</span></b><span class="koboSpan" id="kobo.100.1"> and then adding in the second byte. </span><a href="#fig9-3"><span class="koboSpan" id="kobo.101.1">Figure 9-3</span></a><span class="koboSpan" id="kobo.102.1"> illustrates this process.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig9-3" class="image"><span><span class="koboSpan" id="kobo.103.1"><img alt="image" src="images/fig9-3.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.104.1">Figure 9-3</span></b><span class="koboSpan" id="kobo.105.1">   </span><i><span class="koboSpan" id="kobo.106.1">Combining two bytes into an int</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.107.1">In Arduino C, you first place the </span><b><span class="koboSpan" id="kobo.108.1">highByte</span></b><span class="koboSpan" id="kobo.109.1"> into the </span><b><span class="koboSpan" id="kobo.110.1">int</span></b><span class="koboSpan" id="kobo.111.1"> result variable and then shift it left eight spaces before adding the </span><b><span class="koboSpan" id="kobo.112.1">lowByte</span></b><span class="koboSpan" id="kobo.113.1">:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.114.1"><img alt="image" src="images/p154-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.115.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c9-5" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.116.1">SPI Hardware</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><a href="#fig9-4"><span class="koboSpan" id="kobo.117.1">Figure 9-4</span></a><span class="koboSpan" id="kobo.118.1"> shows a typical configuration for an Arduino with two slave devices.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig9-4" class="image"><span><span class="koboSpan" id="kobo.119.1"><img alt="image" src="images/fig9-4.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.120.1">Figure 9-4</span></b><span class="koboSpan" id="kobo.121.1">   </span><i><span class="koboSpan" id="kobo.122.1">Arduino and two slave SPI devices</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.123.1">On the Arduino, the System Clock (SCLK), Master Out Slave In (MOSI), and Master In Slave Out (MISO) are linked to the Arduino pins of the same name, which map to pins D13, D11, and D12 on an Arduino Uno. </span><a href="#tab9-2"><span class="koboSpan" id="kobo.124.1">Table 9-2</span></a><span class="koboSpan" id="kobo.125.1"> lists the pin assignments on the most common Arduino boards.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="tab9-2" class="imagex"><span><span class="koboSpan" id="kobo.126.1"><img alt="image" src="images/tab9-2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.127.1">Table 9-2</span></b><span class="koboSpan" id="kobo.128.1">   </span><i><span class="koboSpan" id="kobo.129.1">SPI Connections on Arduino Boards</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.130.1">The Slave select pins can be any pins on the Arduino. </span><span class="koboSpan" id="kobo.130.2">They are used to enable a particular slave just before data transmission and then disable it after communication is complete.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.131.1">No pull-up resistors are required on any of the lines.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.132.1">Because some Arduino boards, including the Leonardo, only have SPI connectors that are accessible from the ICSP header pins, shields that use SPI often have a socket header that meets the ICSP male header. </span><a href="#fig9-5"><span class="koboSpan" id="kobo.133.1">Figure 9-5</span></a><span class="koboSpan" id="kobo.134.1"> shows the ICSP header with the ICSP headers labeled.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig9-5" class="image"><span><span class="koboSpan" id="kobo.135.1"><img alt="image" src="images/fig9-5.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.136.1">Figure 9-5</span></b><span class="koboSpan" id="kobo.137.1">   </span><i><span class="koboSpan" id="kobo.138.1">Arduino Uno and ICSP connections</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.139.1">Note that the Arduino Uno has a second ICSP header near the reset button. </span><span class="koboSpan" id="kobo.139.2">This is for programming the USB interface.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.140.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c9-6" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.141.1">The SPI Protocol</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.142.1">The SPI protocol is, at first sight, confusing because data is transmitted and received at the same time by both the master and the currently selected slave. </span><span class="koboSpan" id="kobo.142.2">At the same time that the master (Arduino) sends a bit from its MOSI pin to the corresponding MOSI pin on the slave another bit is being sent back from the Slave’s MISO pin to the Arduino’s MISO pin.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.143.1">Typically, the Arduino sends a byte’s worth of bits and then sends eight zeros while, at the same time, reading the results coming back from the slave. </span><span class="koboSpan" id="kobo.143.2">Because the master sets the transmission frequency, make sure the rate is not too fast for the slave device.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.144.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c9-7" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.145.1">The SPI Library</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.146.1">The SPI library is included with Arduino IDE, so you do not need to install anything to use it. </span><span class="koboSpan" id="kobo.146.2">It only supports Arduino-as-master scenarios. </span><span class="koboSpan" id="kobo.146.3">The library also only directly supports transmission of whole bytes. </span><span class="koboSpan" id="kobo.146.4">For most peripherals, this setup is just fine; however, some devices expect 12-bit messages, which can result in some complicated bit manipulation as you’ll see in the example in the next section of this chapter.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.147.1">The first step is, as usual, to include the SPI library:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.148.1"><img alt="image" src="images/p156-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.149.1">Next, you need to start SPI by issuing the </span><b><span class="koboSpan" id="kobo.150.1">SPI.begin</span></b><span class="koboSpan" id="kobo.151.1"> command in your “startup” function.</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.152.1"><img alt="image" src="images/p156-02.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.153.1">Unless you are using a Due, you also need to set up digital outputs for each of the SS pins to the slave devices. </span><span class="koboSpan" id="kobo.153.2">These outputs can be any Arduino pins. </span><span class="koboSpan" id="kobo.153.3">Having set them to be outputs, you need to set them to HIGH immediately because the slave select logic is inverted, so a LOW means the slave is selected.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.154.1">The Due has extended the SPI library so you can specify one pin to be used for slave selecting, and then the library automatically sets this LOW before transmission and then HIGH after transmission is complete. </span><span class="koboSpan" id="kobo.154.2">You can use this feature simply by specifying the pin to use as the only argument to </span><b><span class="koboSpan" id="kobo.155.1">SPI.begin</span></b><span class="koboSpan" id="kobo.156.1">. </span><span class="koboSpan" id="kobo.156.2">The disadvantage of doing it this way, however, is that it breaks compatibility with other Arduino boards. </span><span class="koboSpan" id="kobo.156.3">In the examples in this chapter, all the slave select pins are controlled manually and are, therefore, suitable for all Arduino boards.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.157.1">A number of utility functions allow you to configure the SPI connection. </span><span class="koboSpan" id="kobo.157.2">However, the defaults will normally work, so you only need to change these settings if the datasheet for the slave device leads you to believe they might need changing. </span><span class="koboSpan" id="kobo.157.3">These functions are summarized in </span><a href="#tab9-3"><span class="koboSpan" id="kobo.158.1">Table 9-3</span></a><span class="koboSpan" id="kobo.159.1">.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="tab9-3" class="imagex"><span><span class="koboSpan" id="kobo.160.1"><img alt="image" src="images/tab9-3.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.161.1">Table 9-3</span></b><span class="koboSpan" id="kobo.162.1">   </span><i><span class="koboSpan" id="kobo.163.1">Configuration Functions</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.164.1">The combined data send and receive happens in the </span><b><span class="koboSpan" id="kobo.165.1">transfer</span></b><span class="koboSpan" id="kobo.166.1"> function. </span><span class="koboSpan" id="kobo.166.2">This function transfers a byte of data and returns the byte of data that it received during the send operation.</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.167.1"><img alt="image" src="images/p157-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.168.1">Because a conversation with a peripheral usually takes the form of the master requesting something from the slave and the slave responding, you’ll often have two transfers in order: one to request the data and the other (a send, probably of 0s) to pull back the data from the peripheral. </span><span class="koboSpan" id="kobo.168.2">You’ll see this in the next example.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.169.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c9-8" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.170.1">SPI Example</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.171.1">This example interfaces a MCP3008 eight-channel ADC IC to an Arduino, adding another eight 10-bit analog inputs to your Arduino. </span><span class="koboSpan" id="kobo.171.2">The chip is low cost and easy to wire.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><a href="#fig9-6"><span class="koboSpan" id="kobo.172.1">Figure 9-6</span></a><span class="koboSpan" id="kobo.173.1"> shows the chip wired to the Arduino using breadboard and jumper wires. </span><span class="koboSpan" id="kobo.173.2">The variable resistor (pot) is used to vary the voltage to analog input 0 between 0 and 5V.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig9-6" class="image"><span><span class="koboSpan" id="kobo.174.1"><img alt="image" src="images/fig9-6.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.175.1">Figure 9-6</span></b><span class="koboSpan" id="kobo.176.1">   </span><i><span class="koboSpan" id="kobo.177.1">Wiring diagram for SPI example</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.178.1">Following is the sketch for this example:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.179.1"><img alt="image" src="images/p159-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.180.1">The function </span><b><span class="koboSpan" id="kobo.181.1">printByte</span></b><span class="koboSpan" id="kobo.182.1"> was just used during development to display the binary data. </span><span class="koboSpan" id="kobo.182.2">Although </span><b><span class="koboSpan" id="kobo.183.1">Serial.print</span></b><span class="koboSpan" id="kobo.184.1"> can display binary values, it does not include leading zeros, which makes interpreting the data difficult, whereas the </span><b><span class="koboSpan" id="kobo.185.1">printByte</span></b><span class="koboSpan" id="kobo.186.1"> function always prints all 8 bits.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.187.1">To see the data coming from the MCP3008, you can remove the </span><b><span class="koboSpan" id="kobo.188.1">//</span></b><span class="koboSpan" id="kobo.189.1"> before the two calls to </span><b><span class="koboSpan" id="kobo.190.1">printByte</span></b><span class="koboSpan" id="kobo.191.1"> and the binary data you are interested in will be displayed.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.192.1">All the interesting code happens in the </span><b><span class="koboSpan" id="kobo.193.1">readADC</span></b><span class="koboSpan" id="kobo.194.1"> function, which takes the ADC channel (0 to 7) as its parameter. </span><span class="koboSpan" id="kobo.194.2">The first thing you need to do is to use some bit manipulation to create the configuration byte that specifies the kind of analog conversion you want to perform and also the channel you want to use.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.195.1">The chip is capable of two ADC operation modes. </span><span class="koboSpan" id="kobo.195.2">One mode is to compare two analog channels, and the second mode (which this example uses) returns the single-ended reading from the channel specified, just like an Arduino analog input. </span><span class="koboSpan" id="kobo.195.3">The datasheet for the MCP3008 (</span><a href="http://ww1.microchip.com/downloads/en/DeviceDoc/21295d.pdf"><span class="koboSpan" id="kobo.196.1">http://ww1.microchip.com/downloads/en/DeviceDoc/21295d.pdf</span></a><span class="koboSpan" id="kobo.197.1">) specifies that the configuration command needs to set four bits: the first bit needs to be 1 for single-ended mode; the next three bits determine the channel (0 to 7) to use.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.198.1">The MCP3008 is not designed for the byte-at-a-time way in which the SPI library works. </span><span class="koboSpan" id="kobo.198.2">In order for the MCP3008 to recognize these 4 bits, we have to split them across 2 bytes. </span><span class="koboSpan" id="kobo.198.3">Here’s the code for doing this:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.199.1"><img alt="image" src="images/p160-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.200.1">The first byte of the configuration message contains two 1s, the first of which may not be needed and the second 1 corresponding to the mode bit (single-ended). </span><span class="koboSpan" id="kobo.200.2">The other 2 bits in this byte are the most significant 2 bits of the analog channel number. </span><span class="koboSpan" id="kobo.200.3">The remaining bit of this number is in the second configuration byte as its most significant bit.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.201.1">The next line sets the SS line for the chip </span><b><span class="koboSpan" id="kobo.202.1">LOW</span></b><span class="koboSpan" id="kobo.203.1"> to enable it.</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.204.1"><img alt="image" src="images/p160-02.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.205.1">After that, the first configuration byte is sent:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.206.1"><img alt="image" src="images/p160-03.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.207.1"><img alt="image" src="images/p161-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.208.1">The analog data will not start arriving until the second configuration byte is sent. </span><span class="koboSpan" id="kobo.208.2">The 10 bits of data from the ADC are split across 2 bytes, so to flush out the remaining data, a call is made to “transfer” sending a byte load of zeros.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.209.1">The SS output is now set </span><b><span class="koboSpan" id="kobo.210.1">HIGH</span></b><span class="koboSpan" id="kobo.211.1"> as the communication is now complete.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.212.1">Finally, the actual 10-bit analog reading value is calculated using the following line:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.213.1"><img alt="image" src="images/p161-02.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.214.1">Each of the 2 bytes has 5 of the 10 bytes of data in it. </span><span class="koboSpan" id="kobo.214.2">The first byte contains these bits in its least significant 5 bits. </span><span class="koboSpan" id="kobo.214.3">All the bits apart from those 5 are masked out and shifted five positions up in the 16-bit </span><b><span class="koboSpan" id="kobo.215.1">int</span></b><span class="koboSpan" id="kobo.216.1">. </span><span class="koboSpan" id="kobo.216.2">The lower byte contains the remainder of the reading in its most significant five digits. </span><span class="koboSpan" id="kobo.216.3">These must be masked and shifted right by three bit positions before they can also be added into the 16-bit </span><b><span class="koboSpan" id="kobo.217.1">int</span></b><span class="koboSpan" id="kobo.218.1">.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.219.1">To test this, open the Serial Monitor. </span><span class="koboSpan" id="kobo.219.2">You should see some data appear. </span><span class="koboSpan" id="kobo.219.3">If you sweep the slider of the pot clockwise from 0 to 5V, you should see something similar to what’s shown in </span><a href="#fig9-7"><span class="koboSpan" id="kobo.220.1">Figure 9-7</span></a><span class="koboSpan" id="kobo.221.1">. </span><span class="koboSpan" id="kobo.221.2">The first two binary numbers are the 2 bytes from the MCP3008 and the final decimal number is the analog reading between 0 and 1023.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig9-7" class="image"><span><span class="koboSpan" id="kobo.222.1"><img alt="image" src="images/fig9-7.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.223.1">Figure 9-7</span></b><span class="koboSpan" id="kobo.224.1">   </span><i><span class="koboSpan" id="kobo.225.1">Viewing the messages in binary</span></i></span></div>
</div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.226.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c9-9" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.227.1">Summary</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.228.1">Interfacing with SPI when no library is available is by no means easy. </span><span class="koboSpan" id="kobo.228.2">You will sometimes need to perform a little trial and error to get things going. </span><span class="koboSpan" id="kobo.228.3">As with any type of debugging, always start by gathering evidence and examining the data that you are receiving. </span><span class="koboSpan" id="kobo.228.4">You will slowly get a picture of what is happening and then be able to tailor your code to produce the desired results.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.229.1">Text chapter examines the final interface standard supported by the Arduino, that of TTL Serial. </span><span class="koboSpan" id="kobo.229.2">This standard is a point-to-point interface rather than a bus, but nonetheless a much-used and handy mechanism for sending and receiving data.</span></span></div>
</div></div></body>
</html>