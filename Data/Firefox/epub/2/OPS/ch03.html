<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.1//EN' 'http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd'>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Programming Arduino™ Next Steps: Going Further with Sketches</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"></meta>
<link href="stylesheet.css" type="text/css" rel="stylesheet"></link>

<!-- kobo-style -->
<link type="text/css" rel="stylesheet" href="css/kobo.css"></link>
<script type="text/javascript" src="js/kobo.js"></script>
<style type="text/css" id="kobostylehacks">div#book-inner p, div#book-inner div { font-size: 1.0em; } a { color: black; } a:link, a:visited, a:hover, a:active { color: blue; } div#book-inner * { margin-top: 0 !important; margin-bottom: 0 !important;}</style>
</head>
<body><div id="book-columns"><div id="book-inner">
<div class="chapnum" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.1.1">3</span></span></div>
<div class="chaptitle" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.2.1">Interrupts and Timers</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="big"><span class="koboSpan" id="kobo.3.1">Interrupts allow</span></span><span class="koboSpan" id="kobo.4.1"> microcontrollers to respond to events without having to poll continually to see if anything has changed. </span><span class="koboSpan" id="kobo.4.2">In addition to associating interrupts with certain pins you can also use timer-generated interrupts.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.5.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c3-1" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.6.1">Hardware Interrupts</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.7.1">As an example of how to use interrupts, let’s revisit digital inputs. </span><span class="koboSpan" id="kobo.7.2">The most common way to detect when something has happened at an input (say a switch has been pressed) is to use some code like this:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.8.1"><img alt="image" src="images/p57-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.9.1">This code means we continually check </span><b><span class="koboSpan" id="kobo.10.1">inputPin</span></b><span class="koboSpan" id="kobo.11.1"> and the moment it reads </span><b><span class="koboSpan" id="kobo.12.1">LOW</span></b><span class="koboSpan" id="kobo.13.1">, we do whatever is specified at the </span><b><span class="koboSpan" id="kobo.14.1">//do something</span></b><span class="koboSpan" id="kobo.15.1"> comment. </span><span class="koboSpan" id="kobo.15.2">This process works well, but what if you have a lot of other things to do inside the loop, too? </span><span class="koboSpan" id="kobo.15.3">These other things take time, so you could potentially miss a very quick button press because the processor is busy doing something else. </span><span class="koboSpan" id="kobo.15.4">In actual fact, with a switch, missing the button press is unlikely as it remains pressed for what in microcontroller terms is a long time.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.16.1">But what about shorter pulses from a sensor, which may only be active for a few millionths of a second? </span><span class="koboSpan" id="kobo.16.2">For these cases, you can use interrupts to receive such events, setting a function to run whenever these events happen, irrespective of whatever else the microcontroller might be doing. </span><span class="koboSpan" id="kobo.16.3">Thus, these are called </span><i><span class="koboSpan" id="kobo.17.1">hardware interrupts</span></i><span class="koboSpan" id="kobo.18.1">.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.19.1">On the Arduino Uno, you can only use two pins as hardware interrupts, which is one reason they are used sparingly. </span><span class="koboSpan" id="kobo.19.2">The Leonardo has four interrupt-capable pins; bigger boards like the Mega2560 have many more; and, on the Due, you can attach all the pins to interrupts.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.20.1">The following shows how hardware interrupts work. </span><span class="koboSpan" id="kobo.20.2">To try this example, you need some breadboard, a tactile push switch, a 1 kΩ resistor, and some jumper wires.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><a href="#fig3-1"><span class="koboSpan" id="kobo.21.1">Figure 3-1</span></a><span class="koboSpan" id="kobo.22.1"> shows the arrangement. </span><span class="koboSpan" id="kobo.22.2">The resistor pulls the interrupt pin (D2) HIGH until the button on the switch is pressed, at which point D2 is grounded and goes LOW.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig3-1" class="image"><span><span class="koboSpan" id="kobo.23.1"><img alt="image" src="images/fig3-1.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.24.1">Figure 3-1</span></b><span class="koboSpan" id="kobo.25.1">   </span><i><span class="koboSpan" id="kobo.26.1">Interrupt test circuit</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.27.1">Load the following sketch onto your Arduino:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.28.1"><img alt="image" src="images/p59-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.29.1">As well as setting the LED pin to be an output, the </span><b><span class="koboSpan" id="kobo.30.1">setup</span></b><span class="koboSpan" id="kobo.31.1"> function also contains a line that associates a function with an interrupt. </span><span class="koboSpan" id="kobo.31.2">So whenever the interrupt occurs, the function is run. </span><span class="koboSpan" id="kobo.31.3">Let’s look at this line closely because its arguments are a little confusing:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.32.1"><img alt="image" src="images/p59-02.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.33.1">The first argument </span><b><span class="koboSpan" id="kobo.34.1">0</span></b><span class="koboSpan" id="kobo.35.1"> is the interrupt number. </span><span class="koboSpan" id="kobo.35.2">It would make far more sense if this were a regular Arduino pin number, but it isn’t. </span><span class="koboSpan" id="kobo.35.3">On an Arduino Uno, interrupt 0 is pin D2 and interrupt 1 is D3. </span><span class="koboSpan" id="kobo.35.4">The situation is made even more confusing because on other types of Arduino, these pins are not the same, and on the Arduino Due, you just specify the pin name. </span><span class="koboSpan" id="kobo.35.5">When using an Arduino Due, all the pins can be used as interrupts.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.36.1">I’ll come back to this later, but for now let’s move on to the second argument. </span><span class="koboSpan" id="kobo.36.2">This argument </span><b><span class="koboSpan" id="kobo.37.1">stuffhappened</span></b><span class="koboSpan" id="kobo.38.1"> is the name of the function to be called when an interrupt occurs. </span><span class="koboSpan" id="kobo.38.2">You can see the function defined later in the sketch. </span><span class="koboSpan" id="kobo.38.3">Such functions have a special name; they are called </span><i><span class="koboSpan" id="kobo.39.1">Interrupt Service Routines</span></i><span class="koboSpan" id="kobo.40.1">, or </span><i><span class="koboSpan" id="kobo.41.1">ISRs</span></i><span class="koboSpan" id="kobo.42.1"> for short. </span><span class="koboSpan" id="kobo.42.2">They cannot have any parameters and should not return anything. </span><span class="koboSpan" id="kobo.42.3">This makes sense: Although you can generally call them from other parts of your sketch, no line of code will have called the ISR, so there is no way for them to be given any parameters or to return a value.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.43.1">The final </span><b><span class="koboSpan" id="kobo.44.1">attachInterrupt</span></b><span class="koboSpan" id="kobo.45.1"> parameter is a constant, in this case, FALLING. </span><span class="koboSpan" id="kobo.45.2">This means the interrupt only results in the ISR being called if D2 goes from HIGH to LOW (in other words, it “falls”), which is what happens when the button is pressed: D2 goes from HIGH to LOW.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.46.1">You’ll notice there is no code in the </span><b><span class="koboSpan" id="kobo.47.1">loop</span></b><span class="koboSpan" id="kobo.48.1"> function. </span><span class="koboSpan" id="kobo.48.2">Normally, the loop function would contain code that would be executed until the interrupt occurred. </span><span class="koboSpan" id="kobo.48.3">The ISR itself simply turns the “L” LED on.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.49.1">When you try the experiment, after the Arduino has reset, the “L” LED should go out. </span><span class="koboSpan" id="kobo.49.2">Then as soon as you press the button, the “L” LED should immediately light up and stay lit.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.50.1">Now change the final argument of </span><b><span class="koboSpan" id="kobo.51.1">attachInterrupt</span></b><span class="koboSpan" id="kobo.52.1"> to </span><b><span class="koboSpan" id="kobo.53.1">RISING</span></b><span class="koboSpan" id="kobo.54.1"> and upload the modified sketch. </span><span class="koboSpan" id="kobo.54.2">The LED should still remain unlit after the Arduino has finished restarting because the interrupt may be HIGH, but it has always been HIGH; it hasn’t, at any point, gone LOW to then “rise” to HIGH.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.55.1">When you press and hold the button, the LED should stay unlit until you release it. </span><span class="koboSpan" id="kobo.55.2">Releasing it triggers the interrupt because D2, which was LOW while the button was pressed, only rises to HIGH when you release it.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.56.1">If this doesn’t seem to work, then the switch is probably bouncing. </span><span class="koboSpan" id="kobo.56.2">There isn’t a perfect jump from open to closed; rather, the switch will actually turn on and off a few times before settling into the on position. </span><span class="koboSpan" id="kobo.56.3">Try it several times, pressing the switch firmly, and you should be able to get a close without a bounce.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.57.1">The other way to test this is to hold the switch while you press the Reset button on the Arduino. </span><span class="koboSpan" id="kobo.57.2">Then when you are ready, release the test button and the “L” LED will light.</span></span></div>
<div id="c3-2" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.58.1">Interrupt Pins</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.59.1">Returning to the thorny issue of how interrupts are named, </span><a href="#tab3-1"><span class="koboSpan" id="kobo.60.1">Table 3-1</span></a><span class="koboSpan" id="kobo.61.1"> shows how the most common Arduino boards map interrupt numbers to physical Arduino pins.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="tab3-1" class="imagex"><span><span class="koboSpan" id="kobo.62.1"><img alt="image" src="images/tab3-1.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.63.1">Table 3-1</span></b><span class="koboSpan" id="kobo.64.1">   </span><i><span class="koboSpan" id="kobo.65.1">Interrupt Pins of Different Arduino Boards</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.66.1">The pin swap for the first two interrupts on the Uno and Leonardo is an easy trap to fall into. </span><span class="koboSpan" id="kobo.66.2">The Due approach of using the Arduino pin name instead of the interrupt number is a much more logical way of doing things.</span></span></div>
<div id="c3-3" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.67.1">Interrupt Modes</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.68.1">The RISING and FALLING modes, which we used in the previous example, are the most handy modes. </span><span class="koboSpan" id="kobo.68.2">There are, however, some other interrupt modes. </span><a href="#tab3-2"><span class="koboSpan" id="kobo.69.1">Table 3-2</span></a><span class="koboSpan" id="kobo.70.1"> lists these modes, along with a description.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="tab3-2" class="imagex"><span><span class="koboSpan" id="kobo.71.1"><img alt="image" src="images/tab3-2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.72.1">Table 3-2</span></b><span class="koboSpan" id="kobo.73.1">   </span><i><span class="koboSpan" id="kobo.74.1">Interrupt Modes</span></i></span></div>
</div>
<div id="c3-4" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.75.1">Enabling Internal Pull-Up</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.76.1">The hardware setup in the previous example uses a pull-up resistor. </span><span class="koboSpan" id="kobo.76.2">Often, the signal that causes the interrupt is from a sensor’s digital output, in which case, you do not need a pull-up resistor.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.77.1">If, however, the sensor is a switch, wired in the same way as the test board shown in </span><a href="#fig3-1"><span class="koboSpan" id="kobo.78.1">Figure 3-1</span></a><span class="koboSpan" id="kobo.79.1">, you can reduce the component count by a resistor if you enable the internal pull-up resistor (about 40 kΩ). </span><span class="koboSpan" id="kobo.79.2">To do this, you need to define the interrupt pin explicitly as being an </span><b><span class="koboSpan" id="kobo.80.1">INPUT_PULLUP</span></b><span class="koboSpan" id="kobo.81.1"> type by adding the bold line, shown here, to the </span><b><span class="koboSpan" id="kobo.82.1">setup</span></b><span class="koboSpan" id="kobo.83.1"> function:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.84.1"><img alt="image" src="images/p62-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c3-5" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.85.1">Interrupt Service Routines</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.86.1">Sometimes the idea of being able to interrupt what is going on in the </span><b><span class="koboSpan" id="kobo.87.1">loop</span></b><span class="koboSpan" id="kobo.88.1"> function can seem like an easy way to catch keypresses and so on. </span><span class="koboSpan" id="kobo.88.2">But actually there are some fairly strict conditions regarding what you can reliably do within an ISR.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.89.1">The first thing is that you normally need to keep an ISR as short and fast as possible. </span><span class="koboSpan" id="kobo.89.2">If another interrupt occurs while an ISR is running, then the ISR will not itself be interrupted; instead, the interrupt signal is ignored until the ISR has finished. </span><span class="koboSpan" id="kobo.89.3">This means that if, for example, you are using the ISR to measure a frequency, you could end up with an incorrect value.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.90.1">Also, while the ISR is running, nothing happens with the code in the </span><b><span class="koboSpan" id="kobo.91.1">loop</span></b><span class="koboSpan" id="kobo.92.1"> function until the ISR has finished.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.93.1">While inside an ISR, interrupts are automatically turned off. </span><span class="koboSpan" id="kobo.93.2">This prevents the potential confusion caused by ISRs interrupting each other, but it has some side effects. </span><span class="koboSpan" id="kobo.93.3">The </span><b><span class="koboSpan" id="kobo.94.1">delay</span></b><span class="koboSpan" id="kobo.95.1"> function uses timers and interrupts, so that won’t work. </span><span class="koboSpan" id="kobo.95.2">The same is true of </span><b><span class="koboSpan" id="kobo.96.1">millis</span></b><span class="koboSpan" id="kobo.97.1">. </span><span class="koboSpan" id="kobo.97.2">And although </span><b><span class="koboSpan" id="kobo.98.1">delay</span></b><span class="koboSpan" id="kobo.99.1"> uses </span><b><span class="koboSpan" id="kobo.100.1">millis</span></b><span class="koboSpan" id="kobo.101.1"> and it will tell you the milliseconds elapsed since reset at the point that the ISR started executing, but it will not change as the ISR runs. </span><span class="koboSpan" id="kobo.101.2">However, you can use </span><b><span class="koboSpan" id="kobo.102.1">delayMicroseconds</span></b><span class="koboSpan" id="kobo.103.1"> because this does not use interrupts.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.104.1">Serial communication also uses interrupts, so do not use </span><b><span class="koboSpan" id="kobo.105.1">Serial.print</span></b><span class="koboSpan" id="kobo.106.1"> or try to read from </span><b><span class="koboSpan" id="kobo.107.1">Serial</span></b><span class="koboSpan" id="kobo.108.1">. </span><span class="koboSpan" id="kobo.108.2">Well, you can try, and it may work, but do not expect it to work reliably all the time.</span></span></div>
<div id="c3-6" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.109.1">Volatile Variables</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.110.1">Because the ISR function is not allowed to take parameters and cannot return a value, you need a way to pass data between the ISR and the rest of the program. </span><span class="koboSpan" id="kobo.110.2">You typically do this using global variables, as the next example illustrates:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.111.1"><img alt="image" src="images/p63-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.112.1">This sketch uses a global variable </span><b><span class="koboSpan" id="kobo.113.1">flashFast</span></b><span class="koboSpan" id="kobo.114.1"> in the </span><b><span class="koboSpan" id="kobo.115.1">loop</span></b><span class="koboSpan" id="kobo.116.1"> function to determine the delay period. </span><span class="koboSpan" id="kobo.116.2">The ISR then toggles this same variable between </span><b><span class="koboSpan" id="kobo.117.1">true</span></b><span class="koboSpan" id="kobo.118.1"> and </span><b><span class="koboSpan" id="kobo.119.1">false</span></b><span class="koboSpan" id="kobo.120.1">.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.121.1">Notice that the declaration of the variable </span><b><span class="koboSpan" id="kobo.122.1">flashFast</span></b><span class="koboSpan" id="kobo.123.1"> includes the word “volatile.” </span><span class="koboSpan" id="kobo.123.2">You may get away with the sketch working if you do not use </span><b><span class="koboSpan" id="kobo.124.1">volatile</span></b><span class="koboSpan" id="kobo.125.1">, but you should use it because if a variable is not declared as being volatile, the C compiler may generate machine code that caches its value in a register to improve performance. </span><span class="koboSpan" id="kobo.125.2">If, as is the case here, this caching process could be interrupted, then the variable might not be updated correctly.</span></span></div>
<div id="c3-7" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.126.1">ISR Summary</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.127.1">Keep these points in mind when writing an ISR:</span></span></div>
<div class="hangbull" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.128.1">•  Keep it fast.</span></span></div>
<div class="hangbull" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.129.1">•  Pass data between the ISR and the rest of the program using </span><b><span class="koboSpan" id="kobo.130.1">volatile</span></b><span class="koboSpan" id="kobo.131.1"> variables.</span></span></div>
<div class="hangbull" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.132.1">•  Don’t use </span><b><span class="koboSpan" id="kobo.133.1">delay</span></b><span class="koboSpan" id="kobo.134.1">, but you can use </span><b><span class="koboSpan" id="kobo.135.1">delayMicroseconds</span></b><span class="koboSpan" id="kobo.136.1">.</span></span></div>
<div class="hangbull" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.137.1">•  Don’t expect serial communications, reading, or writing to be reliable.</span></span></div>
<div class="hangbull" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.138.1">•  Don’t expect the value returned by </span><b><span class="koboSpan" id="kobo.139.1">millis</span></b><span class="koboSpan" id="kobo.140.1"> to change.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.141.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c3-8" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.142.1">Enabling and Disabling Interrupts</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.143.1">By default, interrupts are enabled in a sketch and, as I mentioned previously, are automatically disabled when you are inside an ISR. </span><span class="koboSpan" id="kobo.143.2">However, you can explicitly turn interrupts on and off from your program code using the functions </span><b><span class="koboSpan" id="kobo.144.1">interrupts</span></b><span class="koboSpan" id="kobo.145.1"> and </span><b><span class="koboSpan" id="kobo.146.1">noInterrupts</span></b><span class="koboSpan" id="kobo.147.1">. </span><span class="koboSpan" id="kobo.147.2">Neither function takes any parameters and they turn all interrupts on or off, respectively.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.148.1">You might want to explicitly turn interrupts on and off if you have an area of code that you do not wish to be disturbed, for example, if you are writing serial data or generating pulses with accurate timing using </span><b><span class="koboSpan" id="kobo.149.1">delay-Microseconds</span></b><span class="koboSpan" id="kobo.150.1">.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.151.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c3-9" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.152.1">Timer Interrupts</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.153.1">As well as interrupts being triggered by external events, you can also trigger ISRs to be called as a result of timed events. </span><span class="koboSpan" id="kobo.153.2">This capability can be really useful if you need to do something time-critical.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.154.1">TimerOne makes it easy to set timed interrupts. </span><span class="koboSpan" id="kobo.154.2">You can download the TimerOne library from </span><a href="http://playground.arduino.cc/Code/Timer1"><span class="koboSpan" id="kobo.155.1">http://playground.arduino.cc/Code/Timer1</span></a><span class="koboSpan" id="kobo.156.1">.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.157.1">The following example shows how you can use TimerOne to generate a 1-kHz square wave signal. </span><span class="koboSpan" id="kobo.157.2">If you have an oscilloscope or multimeter with a frequency setting, connect it to pin 12 to see the signal (</span><a href="#fig3-2"><span class="koboSpan" id="kobo.158.1">Figure 3-2</span></a><span class="koboSpan" id="kobo.159.1">).</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig3-2" class="image"><span><span class="koboSpan" id="kobo.160.1"><img alt="image" src="images/fig3-2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.161.1">Figure 3-2</span></b><span class="koboSpan" id="kobo.162.1">   </span><i><span class="koboSpan" id="kobo.163.1">A timer-generated square wave</span></i></span></div>
</div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.164.1"><img alt="image" src="images/p64-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.165.1"><img alt="image" src="images/p65-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.166.1">Although you could have written this using </span><b><span class="koboSpan" id="kobo.167.1">delay</span></b><span class="koboSpan" id="kobo.168.1">, by using a timer interrupt, you can do other things inside the loop. </span><span class="koboSpan" id="kobo.168.2">Also, if you used </span><b><span class="koboSpan" id="kobo.169.1">delay</span></b><span class="koboSpan" id="kobo.170.1">, then the frequency would not be as accurate because the actual time to set the output high would not be accounted for in the delay.</span></span></div>
<div class="note" xmlns="http://www.w3.org/1999/xhtml"><span><b><i><span class="koboSpan" id="kobo.171.1">NOTE</span></i></b><span class="koboSpan" id="kobo.172.1">   </span><i><span class="koboSpan" id="kobo.173.1">All the constraints on what you can do in the ISR for external interrupts also apply to timed interrupts</span></i><span class="koboSpan" id="kobo.174.1">.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.175.1">You can set the timer interrupt period using this method to anything from 1 microsecond to 8,388,480 microseconds, or about 8.4 seconds. </span><span class="koboSpan" id="kobo.175.2">You do this by specifying a period in microseconds in the timer’s </span><b><span class="koboSpan" id="kobo.176.1">initialize</span></b><span class="koboSpan" id="kobo.177.1"> function.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.178.1">The TimerOne library also allows you to use the timer to generate PWM (Pulse Width Modulation) signals on Arduino pins 9 and 10. </span><span class="koboSpan" id="kobo.178.2">This may seem redundant, as you can do that with </span><b><span class="koboSpan" id="kobo.179.1">analogWrite</span></b><span class="koboSpan" id="kobo.180.1"> anyway, but this method gives you better control of the PWM signal. </span><span class="koboSpan" id="kobo.180.2">In particular, it allows you to set the duty cycle between 0 and 1023 rather than the 0 to 255 of </span><b><span class="koboSpan" id="kobo.181.1">analogWrite</span></b><span class="koboSpan" id="kobo.182.1">. </span><span class="koboSpan" id="kobo.182.2">Also, the frequency of the PWM signal when using </span><b><span class="koboSpan" id="kobo.183.1">analogWrite</span></b><span class="koboSpan" id="kobo.184.1"> is fixed at 500 Hz, whereas using TimerOne, you can specify the period for the timer.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.185.1">To use the TimerOne library to generate PWM signals, use </span><b><span class="koboSpan" id="kobo.186.1">Timer1</span></b><span class="koboSpan" id="kobo.187.1">’s </span><b><span class="koboSpan" id="kobo.188.1">pwm</span></b><span class="koboSpan" id="kobo.189.1"> function, as shown in the following code example:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.190.1"><img alt="image" src="images/p66-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.191.1">In this case, I have set the overall period to 1000 microseconds, resulting in a PWM frequency of 1kHz. </span><a href="#fig3-3"><span class="koboSpan" id="kobo.192.1">Figure 3-3</span></a><span class="koboSpan" id="kobo.193.1"> shows the waveforms generated on pin 10 (top) and pin 9 (bottom).</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig3-3" class="image"><span><span class="koboSpan" id="kobo.194.1"><img alt="image" src="images/fig3-3.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.195.1">Figure 3-3</span></b><span class="koboSpan" id="kobo.196.1">   </span><i><span class="koboSpan" id="kobo.197.1">Using TimerOne to generate PWM at 1 kHz</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.198.1">As an experiment, let’s see how far you can push the PWM frequency. </span><span class="koboSpan" id="kobo.198.2">Changing the period to 10 results in a PWM frequency of 100 kHz. </span><span class="koboSpan" id="kobo.198.3">The waveforms for this are shown in </span><a href="#fig3-4"><span class="koboSpan" id="kobo.199.1">Figure 3-4</span></a><span class="koboSpan" id="kobo.200.1">.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig3-4" class="image"><span><span class="koboSpan" id="kobo.201.1"><img alt="image" src="images/fig3-4.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.202.1">Figure 3-4</span></b><span class="koboSpan" id="kobo.203.1">   </span><i><span class="koboSpan" id="kobo.204.1">Using TimerOne to generate a 100-kHz PWM</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.205.1">Although there is, as you would expect, a fair amount of transient noise on the signals, you can see that the duty cycles still look pretty close to 25 percent and 50 percent, respectively.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.206.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c3-10" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.207.1">Summary</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.208.1">Interrupts, although they sometimes seem like the ideal solution to a difficult project, can make the code difficult to debug and are by no means always the best way to handle tasks. </span><span class="koboSpan" id="kobo.208.2">Think carefully before you jump into using them. </span><span class="koboSpan" id="kobo.208.3">In </span><a href="ch14.html"><span class="koboSpan" id="kobo.209.1">Chapter 14</span></a><span class="koboSpan" id="kobo.210.1">, we’ll explore a different technique for getting around the Arduino’s apparent inability to do more than one thing at a time.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.211.1">We will also return to interrupts in </span><a href="ch05.html"><span class="koboSpan" id="kobo.212.1">Chapter 5</span></a><span class="koboSpan" id="kobo.213.1">, where we’ll look at using them to save power by waking a sleeping Arduino periodically, and in </span><a href="ch13.html"><span class="koboSpan" id="kobo.214.1">Chapter 13</span></a><span class="koboSpan" id="kobo.215.1">, where we’ll use them for accurate timing during digital signal processing.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.216.1">In the next chapter, we will be looking at squeezing maximum performance out of an Arduino.</span></span></div>
</div></div></body>
</html>