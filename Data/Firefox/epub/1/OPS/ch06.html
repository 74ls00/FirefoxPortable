<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.1//EN' 'http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd'>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Programming Arduino™ Next Steps: Going Further with Sketches</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"></meta>
<link href="stylesheet.css" type="text/css" rel="stylesheet"></link>

<!-- kobo-style -->
<link type="text/css" rel="stylesheet" href="css/kobo.css"></link>
<script type="text/javascript" src="js/kobo.js"></script>
<style type="text/css" id="kobostylehacks">div#book-inner p, div#book-inner div { font-size: 1.0em; } a { color: black; } a:link, a:visited, a:hover, a:active { color: blue; } div#book-inner * { margin-top: 0 !important; margin-bottom: 0 !important;}</style>
</head>
<body><div id="book-columns"><div id="book-inner">
<div class="chapnum" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.1.1">6</span></span></div>
<div class="chaptitle" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.2.1">Memory</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="big"><span class="koboSpan" id="kobo.3.1">Whereas most</span></span><span class="koboSpan" id="kobo.4.1"> computers have memory capacities measured in gigabytes, the Arduino Uno has just 2kB. </span><span class="koboSpan" id="kobo.4.2">That is more than a million times less memory than a conventional computer. </span><span class="koboSpan" id="kobo.4.3">Having only a little memory to work with focuses the mind wonderfully when writing code, however. </span><span class="koboSpan" id="kobo.4.4">There is no room for the “bloatware” that plagues most computers.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.5.1">Although writing memory-efficient code is important, you shouldn’t do so at the expense of writing code that is easy to read and maintain. </span><span class="koboSpan" id="kobo.5.2">Even with an Arduino’s limited resources, most sketches will not get close to using all the RAM. </span><span class="koboSpan" id="kobo.5.3">You really only need to worry about memory capacity when you have a very complex sketch or a sketch that uses a lot of data.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.6.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c6-1" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.7.1">Arduino Memory</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.8.1">Comparing an Arduino’s memory with that of conventional computers is a little unfair, as they actually use their RAM memory in different ways. </span><a href="#fig6-1"><span class="koboSpan" id="kobo.9.1">Figure 6-1</span></a><span class="koboSpan" id="kobo.10.1"> shows how a PC uses its memory when running a program.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig6-1" class="image"><span><span class="koboSpan" id="kobo.11.1"><img alt="image" src="images/fig6-1.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.12.1">Figure 6-1</span></b><span class="koboSpan" id="kobo.13.1">   </span><i><span class="koboSpan" id="kobo.14.1">How a PC uses memory</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.15.1">When a PC runs a program, it first copies the entire program from the hard disk into RAM and then executes that copy of the program. </span><span class="koboSpan" id="kobo.15.2">Variables in the program then use more of the RAM. </span><span class="koboSpan" id="kobo.15.3">By contrast, </span><a href="#fig6-2"><span class="koboSpan" id="kobo.16.1">Figure 6-2</span></a><span class="koboSpan" id="kobo.17.1"> shows how an Arduino uses memory when a program is run. </span><span class="koboSpan" id="kobo.17.2">The program itself actually runs directly from flash memory. </span><span class="koboSpan" id="kobo.17.3">It is not copied into RAM.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig6-2" class="image"><span><span class="koboSpan" id="kobo.18.1"><img alt="image" src="images/fig6-2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.19.1">Figure 6-2</span></b><span class="koboSpan" id="kobo.20.1">   </span><i><span class="koboSpan" id="kobo.21.1">How an Arduino uses memory</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.22.1">The RAM in an Arduino is only used to hold the contents of variables and other data relating to the running of the program. </span><span class="koboSpan" id="kobo.22.2">RAM is not persistent; that is, when the power is disconnected, the RAM is cleared. </span><span class="koboSpan" id="kobo.22.3">If the program needs to store persistent data, then it must write that data to EEPROM. </span><span class="koboSpan" id="kobo.22.4">The data can then be read back when the sketch restarts.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.23.1">When pushing the limits of an Arduino, you have to worry about both RAM usage and, to a lesser extent, the size of the program in flash memory. </span><span class="koboSpan" id="kobo.23.2">Because an Arduino Uno has 32kB of flash, this limit is not often reached.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.24.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c6-2" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.25.1">Minimizing RAM Usage</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.26.1">As you have seen, the way to reduce RAM usage is to reduce the amount of RAM used by variables.</span></span></div>
<div id="c6-3" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.27.1">Use the Right Data Structures</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.28.1">By far, the most common data type in Arduino C is the </span><b><span class="koboSpan" id="kobo.29.1">int</span></b><span class="koboSpan" id="kobo.30.1">. </span><span class="koboSpan" id="kobo.30.2">Each </span><b><span class="koboSpan" id="kobo.31.1">int</span></b><span class="koboSpan" id="kobo.32.1"> uses 2 bytes, but most of the time, you don’t represent a number between –32,768 and +32,767, and the much smaller range of 0 to 255 offered by a “byte” does just fine. </span><span class="koboSpan" id="kobo.32.2">Most built-in methods that work with an </span><b><span class="koboSpan" id="kobo.33.1">int</span></b><span class="koboSpan" id="kobo.34.1">, will work just the same with a byte.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.35.1">A common example of how this works is variables used for pin numbers. </span><span class="koboSpan" id="kobo.35.2">It is common to use </span><b><span class="koboSpan" id="kobo.36.1">int</span></b><span class="koboSpan" id="kobo.37.1">s for this, as shown in the following example:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.38.1"><img alt="image" src="images/p103-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.39.1">You could easily change the </span><b><span class="koboSpan" id="kobo.40.1">int</span></b><span class="koboSpan" id="kobo.41.1"> array to be an array of bytes instead. </span><span class="koboSpan" id="kobo.41.2">If you do this, the program functions just the same time, but the array will occupy half the memory.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.42.1">A really good way to reduce memory usage is to make sure that any constant variables are declared as such. </span><span class="koboSpan" id="kobo.42.2">To do this, just put the word </span><b><span class="koboSpan" id="kobo.43.1">const</span></b><span class="koboSpan" id="kobo.44.1"> in front of the variable declaration. </span><span class="koboSpan" id="kobo.44.2">Knowing that the value will never change allows the compiler to substitute in the value in place of the variable, which saves space. </span><span class="koboSpan" id="kobo.44.3">For example, the array declaration in the previous example becomes</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.45.1"><img alt="image" src="images/p103-02.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c6-4" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.46.1">Be Careful with Recursion</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><i><span class="koboSpan" id="kobo.47.1">Recursion</span></i><span class="koboSpan" id="kobo.48.1"> is a technique where a function calls itself. </span><span class="koboSpan" id="kobo.48.2">Recursion can be a powerful way of expressing and solving a problem. </span><span class="koboSpan" id="kobo.48.3">In functional programming languages such as LISP and Scheme, recursion is used a great deal.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.49.1">When a function is called, an area of memory called the </span><i><span class="koboSpan" id="kobo.50.1">stack</span></i><span class="koboSpan" id="kobo.51.1"> is used. </span><span class="koboSpan" id="kobo.51.2">Imagine a spring-loaded sweet dispenser, like a Pez</span><small><sup><span class="koboSpan" id="kobo.52.1">™</span></sup></small><span class="koboSpan" id="kobo.53.1"> dispenser, except you are only going to push sweets in from the top or pop sweets off from the top (</span><a href="#fig6-3"><span class="koboSpan" id="kobo.54.1">Figure 6-3</span></a><span class="koboSpan" id="kobo.55.1">). </span><span class="koboSpan" id="kobo.55.2">The term </span><i><span class="koboSpan" id="kobo.56.1">push</span></i><span class="koboSpan" id="kobo.57.1"> is used to indicate something being added to the stack and </span><i><span class="koboSpan" id="kobo.58.1">pop</span></i><span class="koboSpan" id="kobo.59.1"> indicates taking something off the stack.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig6-3" class="image"><span><span class="koboSpan" id="kobo.60.1"><img alt="image" src="images/fig6-3.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.61.1">Figure 6-3</span></b><span class="koboSpan" id="kobo.62.1">   </span><i><span class="koboSpan" id="kobo.63.1">The stack</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.64.1">Every time you call a function, a stack frame is created. </span><span class="koboSpan" id="kobo.64.2">A </span><i><span class="koboSpan" id="kobo.65.1">stack frame</span></i><span class="koboSpan" id="kobo.66.1"> is a small memory record that includes storage space for parameters and local variables used by the function, as well as a return address that specifies the point in the program from which execution should continue when the function has finished running and returned.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.67.1">Initially, the stack is empty, but when you call a function (let’s call it “function A”), memory is allocated for it and a stack frame is pushed onto the stack. </span><span class="koboSpan" id="kobo.67.2">If function A calls another function (function B), then a second record is added to the top of the stack, so the stack now has two records. </span><span class="koboSpan" id="kobo.67.3">When function B finishes, its stack frame is popped off the stack, then when function A completes, its stack frame is also popped off the stack. </span><span class="koboSpan" id="kobo.67.4">Because local variables for a function are stored on the stack frame, they are not remembered between successive function calls.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.68.1">The stack uses some of our valuable memory, and most of the time, the stack never has more than three or four records on it. </span><span class="koboSpan" id="kobo.68.2">The exception is if you allow functions to call themselves, or to be in a loop of functions calling each other. </span><span class="koboSpan" id="kobo.68.3">Then there is the real possibility that the program will run out of stack memory.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.69.1">For example, the mathematical “factorial” function is calculated by multiplying all the integers that come before a number up to that number. </span><span class="koboSpan" id="kobo.69.2">The factorial of 6 is 6 × 5 × 4 × 3 × 2 × 1 = 720.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.70.1">A recursive definition of the factorial of </span><i><span class="koboSpan" id="kobo.71.1">n</span></i><span class="koboSpan" id="kobo.72.1"> is</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.73.1">If </span><i><span class="koboSpan" id="kobo.74.1">n</span></i><span class="koboSpan" id="kobo.75.1"> = 0, the factorial of </span><i><span class="koboSpan" id="kobo.76.1">n</span></i><span class="koboSpan" id="kobo.77.1"> is 1.</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.78.1">Otherwise the factorial of </span><i><span class="koboSpan" id="kobo.79.1">n</span></i><span class="koboSpan" id="kobo.80.1"> is </span><i><span class="koboSpan" id="kobo.81.1">n</span></i><span class="koboSpan" id="kobo.82.1"> times the factorial of (</span><i><span class="koboSpan" id="kobo.83.1">n</span></i><span class="koboSpan" id="kobo.84.1"> – 1).</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.85.1">You can write this in Arduino C as:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.86.1"><img alt="image" src="images/p105-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.87.1">You can find this code and a full sketch that prints the result in </span><b><span class="koboSpan" id="kobo.88.1">sketch_06_02_factorial</span></b><span class="koboSpan" id="kobo.89.1">. </span><span class="koboSpan" id="kobo.89.2">Generally, people with a mathematical mind think this is pretty neat. </span><span class="koboSpan" id="kobo.89.3">You’ll notice, however, that the depth of the stack equals the number of the factorial you are calculating. </span><span class="koboSpan" id="kobo.89.4">It is also pretty easy to see how to write a nonrecursive version of the </span><b><span class="koboSpan" id="kobo.90.1">factorial</span></b><span class="koboSpan" id="kobo.91.1"> function:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.92.1"><img alt="image" src="images/p106-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.93.1">In terms of ease of reading, this code is probably easier to understand; it also uses less memory and is faster. </span><span class="koboSpan" id="kobo.93.2">In general, it makes sense to avoid recursion, or restrict it to highly efficient recursive algorithms like Quicksort (</span><a href="http://en.wikipedia.org/wiki/Quicksort"><span class="koboSpan" id="kobo.94.1">http://en.wikipedia.org/wiki/Quicksort</span></a><span class="koboSpan" id="kobo.95.1">), which can put an array of numbers into order very efficiently.</span></span></div>
<div id="c6-5" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.96.1">Store String Constants in Flash Memory</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.97.1">By default, if you declare string constants as shown in the following example, those character arrays will be stored in RAM and in flash memory—once for the program code and once when their values are copied into RAM when the sketch is run:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.98.1"><img alt="image" src="images/p106-02.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.99.1">If, however, you use the following code, the string constant will be stored in flash memory only:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.100.1"><img alt="image" src="images/p106-03.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.101.1">In the “Using Flash” section in this chapter, you’ll see how you can use flash in other ways.</span></span></div>
<div id="c6-6" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.102.1">Common Misconceptions</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.103.1">A common misconception is that using short variable names uses less memory. </span><span class="koboSpan" id="kobo.103.2">This is not the case. </span><span class="koboSpan" id="kobo.103.3">The compiler takes care of such things, so the final variable names do not find their way into the binary sketch. </span><span class="koboSpan" id="kobo.103.4">Another misconception is that comments in a program have an effect on the size of the program when it is installed or on the RAM that it uses. </span><span class="koboSpan" id="kobo.103.5">This is not true.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.104.1">You may also assume that dividing your code into lots of small functions will increase the size of the compiled code. </span><span class="koboSpan" id="kobo.104.2">This is not usually the case as the compiler is smart enough to actually replace function calls with inline copies of the body of the function as part of its code optimization process. </span><span class="koboSpan" id="kobo.104.3">This benefit allows you to write more readable code.</span></span></div>
<div id="c6-7" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.105.1">Measure Free Memory</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.106.1">You can find out how much RAM a running sketch is using at any point in time with the </span><b><span class="koboSpan" id="kobo.107.1">MemoryFree</span></b><span class="koboSpan" id="kobo.108.1"> library, which you can download from here: </span><a href="http://playground.arduino.cc/Code/AvailableMemory"><span class="koboSpan" id="kobo.109.1">http://playground.arduino.cc/Code/AvailableMemory</span></a><span class="koboSpan" id="kobo.110.1">.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.111.1">This library is easy to use; it provides a function called </span><b><span class="koboSpan" id="kobo.112.1">freeMemory</span></b><span class="koboSpan" id="kobo.113.1">, which returns the number of bytes available. </span><span class="koboSpan" id="kobo.113.2">The following sketch illustrates its use:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.114.1"><img alt="image" src="images/p107-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.115.1">This library can be handy if you start to experience unexplained problems with a sketch that you think might be caused by a memory shortage. </span><span class="koboSpan" id="kobo.115.2">The library does, of course, increase your memory usage a little.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.116.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c6-8" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.117.1">Minimizing Flash Usage</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.118.1">When you successfully compile a sketch, you’ll see a status line at the end of the process that says something like this:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.119.1"><img alt="image" src="images/p108-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.120.1">This line tells you exactly how much of the Arduino’s flash memory the sketch will use, so you know if you’re getting close to the 32kB limit. </span><span class="koboSpan" id="kobo.120.2">If you are not near the limit, then you don’t really need to try to optimize the flash memory. </span><span class="koboSpan" id="kobo.120.3">If you are getting close, then there are a few things that you can do.</span></span></div>
<div id="c6-9" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.121.1">Use Constants</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.122.1">When variables are defined, especially pin names, it is quite common to see them defined like this:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.123.1"><img alt="image" src="images/p108-02.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.124.1">Unless you plan to change which pin is to be used as the LED pin while the sketch is actually running, then you can use a constant. </span><span class="koboSpan" id="kobo.124.2">Just add the word </span><b><span class="koboSpan" id="kobo.125.1">const</span></b><span class="koboSpan" id="kobo.126.1"> to the front of the declaration:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.127.1"><img alt="image" src="images/p108-03.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.128.1">This change saves you 2 bytes, plus 2 bytes for every place that the constant is used. </span><span class="koboSpan" id="kobo.128.2">For a much used variable, your savings can amount to a few tens of bytes.</span></span></div>
<div id="c6-10" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.129.1">Remove Unwanted Trace</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.130.1">When debugging Arduino sketches, sprinkling the code with </span><b><span class="koboSpan" id="kobo.131.1">Serial.println</span></b><span class="koboSpan" id="kobo.132.1"> commands helps you see the value of variables and work out any bugs in the program. </span><span class="koboSpan" id="kobo.132.2">These commands actually use a fair bit of flash memory. </span><span class="koboSpan" id="kobo.132.3">Any use of </span><b><span class="koboSpan" id="kobo.133.1">Serial.println</span></b><span class="koboSpan" id="kobo.134.1"> pulls about 500 bytes of library code into the sketch. </span><span class="koboSpan" id="kobo.134.2">So, once you are convinced that the sketch is working, remove or comment out these lines.</span></span></div>
<div id="c6-11" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.135.1">Bypass the Bootloader</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.136.1">Back in </span><a href="ch02.html"><span class="koboSpan" id="kobo.137.1">Chapter 2</span></a><span class="koboSpan" id="kobo.138.1">, you discovered how to program the microcontroller directly on the Arduino using the ISP connector and programming hardware. </span><span class="koboSpan" id="kobo.138.2">This approach can save you a valuable couple of kBs, as it means the bootloader does not need to be installed.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.139.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c6-12" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.140.1">Static vs. </span><span class="koboSpan" id="kobo.140.2">Dynamic Memory Allocation</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.141.1">If, like the author, you come from a background of writing large-scale systems in languages such as Java or C#, you’re used to creating objects at runtime and allowing a garbage collector to tidy up behind you. </span><span class="koboSpan" id="kobo.141.2">This approach to programming is simply inappropriate on a microprocessor with just 2kB of memory. </span><span class="koboSpan" id="kobo.141.3">For a start, there is simply no garbage collector, and what is more, allocating and deallocating memory at runtime is rarely necessary in the type of programs written for an Arduino.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.142.1">The following example defines an array statically, as you would normally in a sketch:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.143.1"><img alt="image" src="images/p109-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.144.1">The memory that the array uses is known while the sketch is being compiled; therefore, the compiler can reserve the necessary amount of memory for the array. </span><span class="koboSpan" id="kobo.144.2">This second example also creates an array of the same size, but it allocates the memory for it at runtime, from a pool of available memory. </span><span class="koboSpan" id="kobo.144.3">Note that versions of the Arduino software prior to 1.0.4 do not support </span><b><span class="koboSpan" id="kobo.145.1">malloc</span></b><span class="koboSpan" id="kobo.146.1">.</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.147.1"><img alt="image" src="images/p110-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.148.1">You start by defining a variable </span><b><i><span class="koboSpan" id="kobo.149.1">int *array</span></i></b><span class="koboSpan" id="kobo.150.1">. </span><span class="koboSpan" id="kobo.150.2">The </span><b><span class="koboSpan" id="kobo.151.1">*</span></b><span class="koboSpan" id="kobo.152.1"> indicates that this is a pointer to an integer value (or, in this case, array of ints) rather than a simple value. </span><span class="koboSpan" id="kobo.152.2">The memory to be used by the array itself is not claimed for use by the array until the following line is executed in </span><b><span class="koboSpan" id="kobo.153.1">setup</span></b><span class="koboSpan" id="kobo.154.1">:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.155.1"><img alt="image" src="images/p110-02.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.156.1">The </span><b><span class="koboSpan" id="kobo.157.1">malloc</span></b><span class="koboSpan" id="kobo.158.1"> (</span><i><span class="koboSpan" id="kobo.159.1">memory allocate</span></i><span class="koboSpan" id="kobo.160.1">) command allocates memory from an area of RAM called the </span><i><span class="koboSpan" id="kobo.161.1">heap</span></i><span class="koboSpan" id="kobo.162.1">. </span><span class="koboSpan" id="kobo.162.2">Its argument is the number of bytes to be allocated. </span><span class="koboSpan" id="kobo.162.3">Because the array contains 100 </span><b><span class="koboSpan" id="kobo.163.1">int</span></b><span class="koboSpan" id="kobo.164.1">s, you need to do a little calculation to work out how many bytes to reserve. </span><span class="koboSpan" id="kobo.164.2">Actually, you could just write </span><b><span class="koboSpan" id="kobo.165.1">200</span></b><span class="koboSpan" id="kobo.166.1"> as the parameter to </span><b><span class="koboSpan" id="kobo.167.1">malloc</span></b><span class="koboSpan" id="kobo.168.1"> because you know that each </span><b><span class="koboSpan" id="kobo.169.1">int</span></b><span class="koboSpan" id="kobo.170.1"> occupies 2 bytes of memory, but by using the </span><b><span class="koboSpan" id="kobo.171.1">sizeof</span></b><span class="koboSpan" id="kobo.172.1"> function, you can make sure to get the right number.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.173.1">After the memory has been allocated, you can use the array just as if you had allocated it statically. </span><span class="koboSpan" id="kobo.173.2">The only advantage to allocating it dynamically is that you can delay the decision about how large to make it until the sketch is actually running (runtime).</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.174.1">The danger with dynamic memory allocation is that you can easily get in a situation where memory is allocated but not released, so then the sketch unexpectedly runs out of memory. </span><span class="koboSpan" id="kobo.174.2">Running out of memory can cause the Arduino to hang. </span><span class="koboSpan" id="kobo.174.3">If all the memory is allocated statically, however, this cannot happen.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.175.1">Note that I have developed hundreds of Arduino projects and have yet to find a compelling reason to use dynamic memory allocation on an Arduino.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.176.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c6-13" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.177.1">Strings</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><i><span class="koboSpan" id="kobo.178.1">Strings</span></i><span class="koboSpan" id="kobo.179.1"> (text) are used less commonly in Arduino programming than in more conventional software development. </span><span class="koboSpan" id="kobo.179.2">In most software development, strings are the most used data type because most programming is about user interfaces or databases, which naturally involve text of some sort.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.180.1">Many Arduino programs have no need to represent strings of text at all, or, if they do, it’s in </span><b><span class="koboSpan" id="kobo.181.1">Serial.println</span></b><span class="koboSpan" id="kobo.182.1"> commands used to debug a buggy sketch.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.183.1">There are essentially two methods for using strings in Arduino: the old way (C </span><b><span class="koboSpan" id="kobo.184.1">char</span></b><span class="koboSpan" id="kobo.185.1"> arrays) and the new way, the String Object library.</span></span></div>
<div id="c6-14" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.186.1">C char Arrays</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.187.1">When you define a string constant by typing something like</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.188.1"><img alt="image" src="images/p111-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.189.1">you are statically defining a </span><b><span class="koboSpan" id="kobo.190.1">char</span></b><span class="koboSpan" id="kobo.191.1"> array that is 12 characters long. </span><span class="koboSpan" id="kobo.191.2">It is 12 characters rather than the 11 letters of “Hello World” because there is a final terminating character of 0 to mark the end of the string. </span><span class="koboSpan" id="kobo.191.3">This is the convention for C character strings, and it allows you to use larger arrays of characters than the string that you are interested in at the start (</span><a href="#fig6-4"><span class="koboSpan" id="kobo.192.1">Figure 6-4</span></a><span class="koboSpan" id="kobo.193.1">). </span><span class="koboSpan" id="kobo.193.2">Each character letter, number, or other symbol has a code called its ASCII value.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig6-4" class="image"><span><span class="koboSpan" id="kobo.194.1"><img alt="image" src="images/fig6-4.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.195.1">Figure 6-4</span></b><span class="koboSpan" id="kobo.196.1">   </span><i><span class="koboSpan" id="kobo.197.1">A null-terminated C char array</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.198.1">Note that another commonly used convention for string constants is to write:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.199.1"><img alt="image" src="images/p112-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.200.1">This syntax works similarly but declares </span><b><span class="koboSpan" id="kobo.201.1">message</span></b><span class="koboSpan" id="kobo.202.1"> to be a pointer to a character (the first character of the array).</span></span></div>
<div class="head2" xmlns="http://www.w3.org/1999/xhtml"><span><b><span class="koboSpan" id="kobo.203.1">Formatting Strings with Multiple Prints</span></b></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.204.1">Much of the time, this is the only way you need to use a string, for instance, to display a message on an LCD screen or as a parameter to </span><b><span class="koboSpan" id="kobo.205.1">Serial.println</span></b><span class="koboSpan" id="kobo.206.1">. </span><span class="koboSpan" id="kobo.206.2">You may think that being able to join strings and convert numbers to strings is essential. </span><span class="koboSpan" id="kobo.206.3">For example, let’s look at a specific problem—how to display a message on an LCD screen such as “Temp: 32 C.” </span><span class="koboSpan" id="kobo.206.4">You might believe you need to join the number 32 to a string </span><b><span class="koboSpan" id="kobo.207.1">&quot;Temp: &quot;</span></b><span class="koboSpan" id="kobo.208.1"> and then add the string </span><b><span class="koboSpan" id="kobo.209.1">&quot; C&quot;</span></b><span class="koboSpan" id="kobo.210.1"> onto the end. </span><span class="koboSpan" id="kobo.210.2">Indeed, if you are a Java programmer, you will probably expect to write the following in C:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.211.1"><img alt="image" src="images/p112-02.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.212.1">Sorry, that’s not the way it works in C. </span><span class="koboSpan" id="kobo.212.2">In this case, you can print this message simply by using multiple </span><b><span class="koboSpan" id="kobo.213.1">print</span></b><span class="koboSpan" id="kobo.214.1"> statements, as shown in this example:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.215.1"><img alt="image" src="images/p112-03.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.216.1">This method removes the need for any behind-the-scenes copying of data that would go on during string concatenation in other newer languages.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.217.1">The same multiple outputs approach works with the Serial Monitor and </span><b><span class="koboSpan" id="kobo.218.1">Serial.print</span></b><span class="koboSpan" id="kobo.219.1"> statements. </span><span class="koboSpan" id="kobo.219.2">In this case, you generally make the last print on the line a </span><b><span class="koboSpan" id="kobo.220.1">println</span></b><span class="koboSpan" id="kobo.221.1"> to add a newline to the output.</span></span></div>
<div class="head2" xmlns="http://www.w3.org/1999/xhtml"><span><b><span class="koboSpan" id="kobo.222.1">Formatting Strings with sprintf</span></b></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.223.1">The standard C string library (not to be confused with the Arduino String Object library discussed in the next section) includes a very useful function called </span><b><span class="koboSpan" id="kobo.224.1">sprintf</span></b><span class="koboSpan" id="kobo.225.1"> to format character arrays. </span><span class="koboSpan" id="kobo.225.2">This fits variables into a pattern string, as shown in the following example:</span></span></div>
<div class="indent1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.226.1"><img alt="image" src="images/p112-04.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.227.1">The character array </span><b><span class="koboSpan" id="kobo.228.1">line1</span></b><span class="koboSpan" id="kobo.229.1"> is a string buffer that is used to contain the formatted text. </span><span class="koboSpan" id="kobo.229.2">The size is specified as 17 to allow an extra null character on the end. </span><span class="koboSpan" id="kobo.229.3">I chose the name </span><b><span class="koboSpan" id="kobo.230.1">line1</span></b><span class="koboSpan" id="kobo.231.1"> to illustrate how this could be the contents of the top line of a 16-character by two-line LCD display.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.232.1">The </span><b><span class="koboSpan" id="kobo.233.1">sprintf</span></b><span class="koboSpan" id="kobo.234.1"> command’s first parameter is the character array into which the result is to be written. </span><span class="koboSpan" id="kobo.234.2">The next argument is the formatting string that contains a mixture of literal text like </span><b><span class="koboSpan" id="kobo.235.1">Temp:</span></b><span class="koboSpan" id="kobo.236.1"> and formatting commands like </span><b><span class="koboSpan" id="kobo.237.1">%d</span></b><span class="koboSpan" id="kobo.238.1">. </span><span class="koboSpan" id="kobo.238.2">In this case, </span><b><span class="koboSpan" id="kobo.239.1">%d</span></b><span class="koboSpan" id="kobo.240.1"> means signed decimal. </span><span class="koboSpan" id="kobo.240.2">The remainder of the parameters will be substituted in order into the formatting string in place of the formatting commands.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.241.1">If your LCD display were to show the time on the second line, then you could format the time from separate hours, minutes, and seconds using the following line:</span></span></div>
<div class="indent1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.242.1"><img alt="image" src="images/p113-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.243.1">If you were to print </span><b><span class="koboSpan" id="kobo.244.1">line2</span></b><span class="koboSpan" id="kobo.245.1"> to the Serial Monitor or an LCD screen, it would look like this:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.246.1"><img alt="image" src="images/p113-02.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.247.1">Not only have the numbers been substituted in the correct place, but also a leading zero is in front of the 5 digit. </span><span class="koboSpan" id="kobo.247.2">In the sketch, between each </span><b><span class="koboSpan" id="kobo.248.1">:</span></b><span class="koboSpan" id="kobo.249.1"> you have the formatting commands for the three parts of the time. </span><span class="koboSpan" id="kobo.249.2">For the hour, it is </span><b><span class="koboSpan" id="kobo.250.1">%2d</span></b><span class="koboSpan" id="kobo.251.1">, which means display the value with a length of two digits as a decimal. </span><span class="koboSpan" id="kobo.251.2">The formatting command for minutes and seconds is slightly different (</span><b><span class="koboSpan" id="kobo.252.1">%02d</span></b><span class="koboSpan" id="kobo.253.1">). </span><span class="koboSpan" id="kobo.253.2">This command still means format as two characters, but include a leading zero.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.254.1">Be wary, though, this approach works for </span><b><span class="koboSpan" id="kobo.255.1">int</span></b><span class="koboSpan" id="kobo.256.1">s, but the Arduino developers have not implemented the standard C library formatting for other types such as </span><b><span class="koboSpan" id="kobo.257.1">float</span></b><span class="koboSpan" id="kobo.258.1">s.</span></span></div>
<div class="head2" xmlns="http://www.w3.org/1999/xhtml"><span><b><span class="koboSpan" id="kobo.259.1">Finding the Length of a String</span></b></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.260.1">Because the string within a character array is often smaller than the actual character array containing it, a useful function, called </span><b><span class="koboSpan" id="kobo.261.1">strlen</span></b><span class="koboSpan" id="kobo.262.1">, is available. </span><b><span class="koboSpan" id="kobo.263.1">strlen</span></b><span class="koboSpan" id="kobo.264.1"> counts the number of characters in the array before the null that marks the end of the string.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.265.1">The function returns the size of the string (excluding the null) and takes the character array as its only argument, for instance,</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.266.1"><img alt="image" src="images/p114-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.267.1">returns the number 3.</span></span></div>
<div id="c6-15" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.268.1">The Arduino String Object Library</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.269.1">Versions of the Arduino IDE since version 019, several years ago, have included a String library that is far more familiar and friendly to developers used to Java, Ruby, Python, and so on, where the norm is to construct strings by concatenation, often using “+”. </span><span class="koboSpan" id="kobo.269.2">This library also offers a whole host of useful string searching and manipulation features.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.270.1">This library, of course, comes at the cost of adding several kBs to your sketch size should you use it. </span><span class="koboSpan" id="kobo.270.2">It also uses dynamic memory allocation, with all its associated problems of running out of memory. </span><span class="koboSpan" id="kobo.270.3">So think carefully before you decide to use it. </span><span class="koboSpan" id="kobo.270.4">Many Arduino users stick to C character arrays instead.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.271.1">This library is beautifully easy to use, and if you have used strings in Java, you will be very at home with the Arduino String Object library.</span></span></div>
<div class="head2" xmlns="http://www.w3.org/1999/xhtml"><span><b><span class="koboSpan" id="kobo.272.1">Creating Strings</span></b></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.273.1">You can create the string using a </span><b><span class="koboSpan" id="kobo.274.1">char</span></b><span class="koboSpan" id="kobo.275.1"> array, </span><b><span class="koboSpan" id="kobo.276.1">int</span></b><span class="koboSpan" id="kobo.277.1">, or </span><b><span class="koboSpan" id="kobo.278.1">float</span></b><span class="koboSpan" id="kobo.279.1">, as shown in the following example:</span></span></div>
<div class="indent1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.280.1"><img alt="image" src="images/p114-02.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="head2" xmlns="http://www.w3.org/1999/xhtml"><span><b><span class="koboSpan" id="kobo.281.1">Concatenating Strings</span></b></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.282.1">Strings can then be concatenated with each other and other data types using </span><b><span class="koboSpan" id="kobo.283.1">+</span></b><span class="koboSpan" id="kobo.284.1">. </span><span class="koboSpan" id="kobo.284.2">Try placing the following code in the </span><b><span class="koboSpan" id="kobo.285.1">setup</span></b><span class="koboSpan" id="kobo.286.1"> function of an otherwise empty sketch:</span></span></div>
<div class="indent1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.287.1"><img alt="image" src="images/p114-03.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.288.1">Notice how the final value being concatenated to the </span><b><span class="koboSpan" id="kobo.289.1">String</span></b><span class="koboSpan" id="kobo.290.1"> is actually a character array. </span><span class="koboSpan" id="kobo.290.2">As long as the first item in the sequence of values in between the </span><b><span class="koboSpan" id="kobo.291.1">+</span></b><span class="koboSpan" id="kobo.292.1"> signs is a string, the items will automatically be converted into strings before being concatenated.</span></span></div>
<div class="head2" xmlns="http://www.w3.org/1999/xhtml"><span><b><span class="koboSpan" id="kobo.293.1">Other String Functions</span></b></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><a href="#tab6-1"><span class="koboSpan" id="kobo.294.1">Table 6-1</span></a><span class="koboSpan" id="kobo.295.1"> summarizes some of the more useful things that you can do with String functions. </span><span class="koboSpan" id="kobo.295.2">For chapter and verse on the functions available, see this reference: </span><a href="http://arduino.cc/en/Reference/StringObject"><span class="koboSpan" id="kobo.296.1">http://arduino.cc/en/Reference/StringObject</span></a><span class="koboSpan" id="kobo.297.1">.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="tab6-1" class="imagex"><span><span class="koboSpan" id="kobo.298.1"><img alt="image" src="images/tab6-1.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.299.1">Table 6-1</span></b><span class="koboSpan" id="kobo.300.1">   </span><i><span class="koboSpan" id="kobo.301.1">Some Useful String Functions</span></i></span></div>
</div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.302.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c6-16" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.303.1">Using EEPROM</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.304.1">The contents of any variable used in an Arduino sketch will be cleared and lost whenever the Arduino loses power or is reset. </span><span class="koboSpan" id="kobo.304.2">If you need to store values persistently, you need to write them a byte at a time into EEPROM memory. </span><span class="koboSpan" id="kobo.304.3">The Arduino Uno has 1kB of EEPROM memory.</span></span></div>
<div class="note" xmlns="http://www.w3.org/1999/xhtml"><span><b><i><span class="koboSpan" id="kobo.305.1">NOTE</span></i></b><span class="koboSpan" id="kobo.306.1">   </span><i><span class="koboSpan" id="kobo.307.1">This is not an option for the Arduino Due, which does not have any EEPROM. </span><span class="koboSpan" id="kobo.307.2">Instead you must write data to a microSD card</span></i><span class="koboSpan" id="kobo.308.1">.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.309.1">Reading and writing to EEPROM memory requires a library that is preinstalled in the Arduino IDE. </span><span class="koboSpan" id="kobo.309.2">The following example shows how to write a single byte of EEPROM, in this case, from the </span><b><span class="koboSpan" id="kobo.310.1">setup</span></b><span class="koboSpan" id="kobo.311.1"> function:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.312.1"><img alt="image" src="images/p116-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.313.1">The first argument of the </span><b><span class="koboSpan" id="kobo.314.1">write</span></b><span class="koboSpan" id="kobo.315.1"> function is the address in the EEPROM to which the byte should be written, and the second argument is the value to be written to that address.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.316.1">The </span><b><span class="koboSpan" id="kobo.317.1">read</span></b><span class="koboSpan" id="kobo.318.1"> command is used to read the data back from EEPROM. </span><span class="koboSpan" id="kobo.318.2">To read back a single byte, you just use the line</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.319.1"><img alt="image" src="images/p116-02.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.320.1">where </span><b><span class="koboSpan" id="kobo.321.1">0</span></b><span class="koboSpan" id="kobo.322.1"> is the EEPROM address.</span></span></div>
<div id="c6-17" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.323.1">EEPROM Example</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.324.1">The following example shows a typical scenario where a value is written during the normal running of a program and then read back during startup. </span><span class="koboSpan" id="kobo.324.2">The application is a door lock project using the Serial Monitor to enter codes and change the secret code. </span><span class="koboSpan" id="kobo.324.3">The EEPROM is used so the secret code can be changed. </span><span class="koboSpan" id="kobo.324.4">If the code had to be reset every time the Arduino started, then there would be no point in allowing the user to change the code.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.325.1">During the discussion that follows, certain areas of the sketch will be highlighted. </span><span class="koboSpan" id="kobo.325.2">If you wish to see the entire sketch in your Arduino IDE, it is called </span><b><span class="koboSpan" id="kobo.326.1">sketch_06_06_EEPROM_example</span></b><span class="koboSpan" id="kobo.327.1"> and can be found with the rest of the code for this book at </span><a href="http://www.simonmonk.org"><span class="koboSpan" id="kobo.328.1">www.simonmonk.org</span></a><span class="koboSpan" id="kobo.329.1">. </span><span class="koboSpan" id="kobo.329.2">You may find it useful to run the sketch to get a feel for how it works. </span><span class="koboSpan" id="kobo.329.3">It does not require that you connect any extra hardware to the Arduino.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.330.1">The </span><b><span class="koboSpan" id="kobo.331.1">setup</span></b><span class="koboSpan" id="kobo.332.1"> function contains a call to the function </span><b><span class="koboSpan" id="kobo.333.1">initializeCode</span></b><span class="koboSpan" id="kobo.334.1">.</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.335.1"><img alt="image" src="images/p116-03.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.336.1"><img alt="image" src="images/p117-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.337.1">This function’s job is to set the variable </span><b><i><span class="koboSpan" id="kobo.338.1">code</span></i></b><span class="koboSpan" id="kobo.339.1"> (the secret code) to its value. </span><span class="koboSpan" id="kobo.339.2">This value is generally a value read from EEPROM, but there are a few difficulties with this setup.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.340.1">EEPROM contents are not cleared by uploading a new sketch; once written, EEPROM values can only be changed by writing a new value on top of the old value. </span><span class="koboSpan" id="kobo.340.2">So if this is the first time that the sketch has been run, then there is no way to know what value might be left in EEPROM by a previous sketch. </span><span class="koboSpan" id="kobo.340.3">You could be left with a lock, that is, a code whose value you do not know.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.341.1">One way around this is to create a separate sketch specifically to set the default code. </span><span class="koboSpan" id="kobo.341.2">This sketch would need to be installed on the Arduino before the main sketch.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.342.1">A second, less reliable, but more convenient approach is to use a marker value that you write to the EEPROM to indicate that the EEPROM has had a code written to it. </span><span class="koboSpan" id="kobo.342.2">The downside of this approach is there is a slim chance that the EEPROM location used to store this flag already contains it. </span><span class="koboSpan" id="kobo.342.3">If so, this solution would be unacceptable if you were defining a commercial product, but here you can elect to take that risk.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.343.1">The </span><b><span class="koboSpan" id="kobo.344.1">initializeCode</span></b><span class="koboSpan" id="kobo.345.1"> function reads the first byte of EEPROM and if it equals </span><b><span class="koboSpan" id="kobo.346.1">codeMarkerValue</span></b><span class="koboSpan" id="kobo.347.1">, which is set elsewhere to 123, it is assumed that the EEPROM contains the code and the function </span><b><span class="koboSpan" id="kobo.348.1">readSecretCodeFromEEPROM</span></b><span class="koboSpan" id="kobo.349.1"> is called:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.350.1"><img alt="image" src="images/p117-02.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.351.1">This function reads the 2-byte int code in bytes 1 and 2 of the EEPROM (</span><a href="#fig6-5"><span class="koboSpan" id="kobo.352.1">Figure 6-5</span></a><span class="koboSpan" id="kobo.353.1">).</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig6-5" class="image"><span><span class="koboSpan" id="kobo.354.1"><img alt="image" src="images/fig6-5.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.355.1">Figure 6-5</span></b><span class="koboSpan" id="kobo.356.1">   </span><i><span class="koboSpan" id="kobo.357.1">Storing an int in EEPROM</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.358.1">To convert the two separate bytes into a single </span><b><span class="koboSpan" id="kobo.359.1">int</span></b><span class="koboSpan" id="kobo.360.1">, you have to shift the high bytes to the right 8 binary digits (high &lt;&lt; 8) and then add the low bytes.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.361.1">The stored code is only read when the Arduino resets. </span><span class="koboSpan" id="kobo.361.2">You should, however, write the secret code to EEPROM every time it is changed, so if the Arduino is powered down or reset, it still has the code available in EEPROM to be read back.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.362.1">The function </span><b><span class="koboSpan" id="kobo.363.1">saveSecretCodeToEEPROM</span></b><span class="koboSpan" id="kobo.364.1"> is responsible for this:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.365.1"><img alt="image" src="images/p118-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.366.1">This sets the code marker in EEPROM position 0 to indicate that there is a valid code in EEPROM and then writes the two bytes of the code to EEPROM. </span><span class="koboSpan" id="kobo.366.2">The Arduino utility functions </span><b><span class="koboSpan" id="kobo.367.1">highByte</span></b><span class="koboSpan" id="kobo.368.1"> and </span><b><span class="koboSpan" id="kobo.369.1">lowByte</span></b><span class="koboSpan" id="kobo.370.1"> are used to separate the parts of the </span><b><span class="koboSpan" id="kobo.371.1">int</span></b><span class="koboSpan" id="kobo.372.1"> code.</span></span></div>
<div id="c6-18" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.373.1">Using the avr/eeprom.h Library</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.374.1">The Arduino EEPROM library only allows you to read and write one byte at a time. </span><span class="koboSpan" id="kobo.374.2">In the example shown in the previous section, you got around this restriction by splitting the </span><b><span class="koboSpan" id="kobo.375.1">int</span></b><span class="koboSpan" id="kobo.376.1"> into two bytes in order to save and retrieve it in EEPROM. </span><span class="koboSpan" id="kobo.376.2">An alternative is to use the underlying EEPROM library provided by AVR. </span><span class="koboSpan" id="kobo.376.3">This gives you more options, including reading and writing a Word (16 bits) and blocks of memory of arbitrary size.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.377.1">The following sketch uses this library to save and read an </span><b><span class="koboSpan" id="kobo.378.1">int</span></b><span class="koboSpan" id="kobo.379.1"> directly, incrementing it every time the Arduino restarts:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.380.1"><img alt="image" src="images/p119-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.381.1">The argument to </span><b><span class="koboSpan" id="kobo.382.1">eeprom_read_word</span></b><span class="koboSpan" id="kobo.383.1"> (10) and the first argument to </span><b><span class="koboSpan" id="kobo.384.1">eeprom_write_word</span></b><span class="koboSpan" id="kobo.385.1"> are the starting position of the word. </span><span class="koboSpan" id="kobo.385.2">Note that this occupies two bytes, so if you want to save another </span><b><span class="koboSpan" id="kobo.386.1">int</span></b><span class="koboSpan" id="kobo.387.1">, you specify an address of 12, not 11. </span><span class="koboSpan" id="kobo.387.2">The text </span><b><span class="koboSpan" id="kobo.388.1">(uint16_t*)</span></b><span class="koboSpan" id="kobo.389.1"> before 10 is needed to make the index position the type expected by the library function.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.390.1">The other useful pair of functions in this library are </span><b><span class="koboSpan" id="kobo.391.1">eeprom_read_block</span></b><span class="koboSpan" id="kobo.392.1"> and </span><b><span class="koboSpan" id="kobo.393.1">eeprom_write_block</span></b><span class="koboSpan" id="kobo.394.1">. </span><span class="koboSpan" id="kobo.394.2">These functions allow data structures of any length (space permitting) to be stored and retrieved.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.395.1">For example, let’s make a sketch to write a character array string, starting at position 100 in EEPROM:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.396.1"><img alt="image" src="images/p119-02.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.397.1"><img alt="image" src="images/p120-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.398.1">The first argument to </span><b><span class="koboSpan" id="kobo.399.1">eeprom_write_block</span></b><span class="koboSpan" id="kobo.400.1"> is the pointer to the char array to be written, the second is the starting location in EEPROM (</span><b><span class="koboSpan" id="kobo.401.1">100</span></b><span class="koboSpan" id="kobo.402.1">). </span><span class="koboSpan" id="kobo.402.2">The final argument is the number of bytes to write. </span><span class="koboSpan" id="kobo.402.3">This is calculated here as the length of the string plus one to include the null character at the end of the string.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.403.1">The following sketch reads the string back in again and displays it on the Serial Monitor along with the string length:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.404.1"><img alt="image" src="images/p120-02.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.405.1">To read the string, a character array of size </span><b><span class="koboSpan" id="kobo.406.1">50</span></b><span class="koboSpan" id="kobo.407.1"> is created. </span><span class="koboSpan" id="kobo.407.2">The function </span><b><span class="koboSpan" id="kobo.408.1">eeprom_read_block</span></b><span class="koboSpan" id="kobo.409.1"> is then used to read the next 50 characters into </span><b><span class="koboSpan" id="kobo.410.1">message</span></b><span class="koboSpan" id="kobo.411.1">. </span><span class="koboSpan" id="kobo.411.2">The </span><b><span class="koboSpan" id="kobo.412.1">&amp;</span></b><span class="koboSpan" id="kobo.413.1"> sign before </span><b><span class="koboSpan" id="kobo.414.1">message</span></b><span class="koboSpan" id="kobo.415.1"> provides the function with the message’s address in RAM.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.416.1">Because the message has a null on the end, when it is printed by the Serial Monitor, only the text expected (not the full 50 characters) is displayed.</span></span></div>
<div id="c6-19" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.417.1">EEPROM Limitations</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.418.1">EEPROM is slow to read and write (about 3ms). </span><span class="koboSpan" id="kobo.418.2">It is also only guaranteed to be reliable for 100,000 write cycles before it starts suffering from amnesia. </span><span class="koboSpan" id="kobo.418.3">For this reason, you need to be careful not to write to it every time around a loop, for example.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.419.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c6-20" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.420.1">Using Flash</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.421.1">An Arduino has a lot more flash memory than it does any other type of memory. </span><span class="koboSpan" id="kobo.421.2">For an Arduino Uno, that is 32kB compared with 2kB of RAM. </span><span class="koboSpan" id="kobo.421.3">This makes it a tempting place to store data, especially as flash memory does not forget when it loses power.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.422.1">There are, however, a few snags with storing data in flash memory:</span></span></div>
<div class="hangbull" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.423.1">•  The flash memory in an Arduino can only be written to about 10,000 times before it becomes useless.</span></span></div>
<div class="hangbull" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.424.1">•  The flash contains your program, so, if you miscalculate and write over the program, very strange things could happen.</span></span></div>
<div class="hangbull" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.425.1">•  The flash also contains the bootloader and overwriting that will “brick” your Arduino unless you have an ISP programmer to rescue it (see </span><a href="ch02.html"><span class="koboSpan" id="kobo.426.1">Chapter 2</span></a><span class="koboSpan" id="kobo.427.1">).</span></span></div>
<div class="hangbull" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.428.1">•  Flash can only be written a block (64 bytes) at a time.</span></span></div>
<div class="indent1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.429.1">Having said all that, it is quite easy and safe to use flash to hold constant data that are not going to change during the running of a sketch.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.430.1">A third-party library is being developed that allows the Arduino Due’s flash memory to be read and written to, to make up for its lack of EEPROM. </span><span class="koboSpan" id="kobo.430.2">You can find out more about this project here: </span><a href="http://pansenti.wordpress.com/2013/04/19/simple-flash-library-for-arduino-due/"><span class="koboSpan" id="kobo.431.1">http://pansenti.wordpress.com/2013/04/19/simple-flash-library-for-arduino-due/</span></a><span class="koboSpan" id="kobo.432.1">.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.433.1">The easiest way to create flash-stored string constants is to use the </span><b><span class="koboSpan" id="kobo.434.1">F</span></b><span class="koboSpan" id="kobo.435.1"> function that I described in an earlier section. </span><span class="koboSpan" id="kobo.435.2">The syntax is repeated here as a reminder:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.436.1"><img alt="image" src="images/p121-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.437.1">This form only works when you are using the string constant directly in a message like this. </span><span class="koboSpan" id="kobo.437.2">You cannot, for example, assign the result to a </span><b><span class="koboSpan" id="kobo.438.1">char</span></b><span class="koboSpan" id="kobo.439.1"> pointer.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.440.1">A more flexible, and therefore more complex, way of doing this is to use the Program Memory (PROGMEM) directive, which can be used to store any data structure. </span><span class="koboSpan" id="kobo.440.2">The data, however, must be constant data that will not change during the running of the sketch.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.441.1">The following example illustrates how you can create an array of </span><b><span class="koboSpan" id="kobo.442.1">int</span></b><span class="koboSpan" id="kobo.443.1">s that will be stored in flash memory:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.444.1"><img alt="image" src="images/p122-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.445.1">By putting the </span><b><span class="koboSpan" id="kobo.446.1">PROGMEM</span></b><span class="koboSpan" id="kobo.447.1"> directive in front of the array declaration, you ensure that it is only stored in flash memory. </span><span class="koboSpan" id="kobo.447.2">To read value out of it, however, you now have to use the function </span><b><span class="koboSpan" id="kobo.448.1">pgm_read_word</span></b><span class="koboSpan" id="kobo.449.1"> from the </span><b><span class="koboSpan" id="kobo.450.1">avr/pgmspace</span></b><span class="koboSpan" id="kobo.451.1"> library:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.452.1"><img alt="image" src="images/p122-02.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.453.1">The parameter to this function uses the </span><b><span class="koboSpan" id="kobo.454.1">&amp;</span></b><span class="koboSpan" id="kobo.455.1"> symbol in front of the array name to indicate that it is the address of this array element in flash memory that is required rather than the value itself.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.456.1">The </span><b><span class="koboSpan" id="kobo.457.1">pgm_read_word</span></b><span class="koboSpan" id="kobo.458.1"> function reads a word (2 bytes) from flash; you can also use the </span><b><span class="koboSpan" id="kobo.459.1">pgm_read_byte</span></b><span class="koboSpan" id="kobo.460.1"> and </span><b><span class="koboSpan" id="kobo.461.1">pgm_read_dword</span></b><span class="koboSpan" id="kobo.462.1"> to read 1 byte and 4 bytes, respectively.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.463.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c6-21" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.464.1">Using SD Card Storage</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.465.1">Although Arduino boards do not have SD card slots, several different types of shield, including the Ethernet shield and the MP3 shield shown in </span><a href="#fig6-6"><span class="koboSpan" id="kobo.466.1">Figure 6-6</span></a><span class="koboSpan" id="kobo.467.1">, do have an SD or microSD card slot.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig6-6" class="image"><span><span class="koboSpan" id="kobo.468.1"><img alt="image" src="images/fig6-6.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.469.1">Figure 6-6</span></b><span class="koboSpan" id="kobo.470.1">   </span><i><span class="koboSpan" id="kobo.471.1">MP3 shield with microSD card slot</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.472.1">SD cards use the SPI bus interface (the topic of </span><a href="ch09.html"><span class="koboSpan" id="kobo.473.1">Chapter 9</span></a><span class="koboSpan" id="kobo.474.1">). </span><span class="koboSpan" id="kobo.474.2">Fortunately, to use SD cards with Arduino, you do not need to do any low-level SPI programming as there is a library included with the Arduino IDE called simply “SD.”</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.475.1">This library includes a set of example sketches for using the SD card in various ways, including finding out information about the SD card as displayed in the Serial Monitor, as shown in </span><a href="#fig6-7"><span class="koboSpan" id="kobo.476.1">Figure 6-7</span></a><span class="koboSpan" id="kobo.477.1">.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig6-7" class="image"><span><span class="koboSpan" id="kobo.478.1"><img alt="image" src="images/fig6-7.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.479.1">Figure 6-7</span></b><span class="koboSpan" id="kobo.480.1">   </span><i><span class="koboSpan" id="kobo.481.1">Results of the Cardinfo example sketch</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.482.1">Writing to the SD card is made easy, as the code snippet here shows:</span></span></div>
<div class="indent1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.483.1"><img alt="image" src="images/p124-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.484.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c6-22" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.485.1">Summary</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.486.1">In this chapter, you have learned about all aspects of memory and data storage within Arduino. </span><span class="koboSpan" id="kobo.486.2">In the next chapters, you will explore Arduino programming for various types of serial interface, starting with the I2C bus.</span></span></div>
</div></div></body>
</html>