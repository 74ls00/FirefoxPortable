<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.1//EN' 'http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd'>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Programming Arduino™ Next Steps: Going Further with Sketches</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"></meta>
<link href="stylesheet.css" type="text/css" rel="stylesheet"></link>

<!-- kobo-style -->
<link type="text/css" rel="stylesheet" href="css/kobo.css"></link>
<script type="text/javascript" src="js/kobo.js"></script>
<style type="text/css" id="kobostylehacks">div#book-inner p, div#book-inner div { font-size: 1.0em; } a { color: black; } a:link, a:visited, a:hover, a:active { color: blue; } div#book-inner * { margin-top: 0 !important; margin-bottom: 0 !important;}</style>
</head>
<body><div id="book-columns"><div id="book-inner">
<div class="chapnum" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.1.1">4</span></span></div>
<div class="chaptitle" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.2.1">Making Arduino Faster</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="big"><span class="koboSpan" id="kobo.3.1">This chapter</span></span><span class="koboSpan" id="kobo.4.1"> is all about finding out how fast your Arduino is and squeezing it for that extra bit of horse-power when you need it.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.5.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c4-1" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.6.1">How Fast Is an Arduino?</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.7.1">Before you start worrying about improving the speed of your sketches, let’s take a moment to benchmark your Arduino to see just how it compares with other computers, starting with the oft-quoted MHz and GHz.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.8.1">An Arduino Uno is clocked at 16 MHz. </span><span class="koboSpan" id="kobo.8.2">As most instructions (adding or storing a value in a variable) are executed in a single clock cycle, that means the Uno can do 16 million things in one second. </span><span class="koboSpan" id="kobo.8.3">Sounds pretty good, doesn’t it? </span><span class="koboSpan" id="kobo.8.4">The story is not that simple, however, as the C that you write in a sketch expands into quite a few instructions.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.9.1">Now contrast that with the author’s aging Mac laptop that has two processors that are each clocked at 2.5 GHz. </span><span class="koboSpan" id="kobo.9.2">My laptop has a clock frequency of over 150 times the frequency of the Arduino. </span><span class="koboSpan" id="kobo.9.3">Albeit, the processor takes a few more clock cycles to do each instruction, but as you would expect, it is a lot faster.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.10.1">Let’s try running the following test program on both an Arduino and a slightly modified version on my Mac:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.11.1"><img alt="image" src="images/p69-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.12.1"><img alt="image" src="images/p70-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="note" xmlns="http://www.w3.org/1999/xhtml"><span><b><i><span class="koboSpan" id="kobo.13.1">NOTE</span></i></b><span class="koboSpan" id="kobo.14.1">   </span><i><span class="koboSpan" id="kobo.15.1">You can find the C counterpart to this code in the download area for code on the book’s website</span></i><span class="koboSpan" id="kobo.16.1">.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.17.1">Here are the results: on a 2.5-GHz MacBook Pro, the test program took 0.068 seconds to run, whereas on an Arduino Uno, the code took 28 seconds to execute. </span><span class="koboSpan" id="kobo.17.2">The Arduino is roughly 400 times slower for this particular task.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.18.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c4-2" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.19.1">Comparing Arduino Boards</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><a href="#tab4-1"><span class="koboSpan" id="kobo.20.1">Table 4-1</span></a><span class="koboSpan" id="kobo.21.1"> shows the result of running this test on a few different Arduino boards.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="tab4-1" class="imagex"><span><span class="koboSpan" id="kobo.22.1"><img alt="image" src="images/tab4-1.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.23.1">Table 4-1</span></b><span class="koboSpan" id="kobo.24.1">   </span><i><span class="koboSpan" id="kobo.25.1">Arduino Performance Test Results</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.26.1">As you can see, the results for most of the boards are consistent, however, the Due results are impressive—more than ten times faster than the other boards.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.27.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c4-3" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.28.1">Speeding Up Arithmetic</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.29.1">As an exercise let’s change the benchmark code that we just used and do the arithmetic with floats rather than longs. </span><span class="koboSpan" id="kobo.29.2">Both are 32-bit numbers, so you might expect the time to complete the task to be similar. </span><span class="koboSpan" id="kobo.29.3">An Arduino Uno is used in the following test.</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.30.1"><img alt="image" src="images/p71-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.31.1">Unfortunately, the task takes a lot longer using floats. </span><span class="koboSpan" id="kobo.31.2">This example takes the Arduino some 467 seconds instead of 28. </span><span class="koboSpan" id="kobo.31.3">So, by changing to floats, my code became about 16 times slower than when I used doubles. </span><span class="koboSpan" id="kobo.31.4">To be fair, some of that performance cost was probably also due to converting between float and integer types, which is also quite costly in terms of time.</span></span></div>
<div id="c4-4" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.32.1">Do You Really Need to Use a Float?</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.33.1">A common misconception is that if you are measuring something like temperature, then you need to store it in a float because it will often be a number like 23.5. </span><span class="koboSpan" id="kobo.33.2">In fact, you may sometimes wish to display the temperature as a float, but you do not need to store it as a float in your sketch.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.34.1">An analog input results in an </span><b><span class="koboSpan" id="kobo.35.1">int</span></b><span class="koboSpan" id="kobo.36.1"> being read, in fact, only 12 bits of an </span><b><span class="koboSpan" id="kobo.37.1">int</span></b><span class="koboSpan" id="kobo.38.1">, which is a number between 0 and 1023. </span><span class="koboSpan" id="kobo.38.2">You can put those 12 bits into a 32-bit float if you like, but you will not be making the data any more accurate or precise.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.39.1">This sensor reading could, for example, correspond to a temperature in degrees Celsius (C). </span><span class="koboSpan" id="kobo.39.2">One commonly used sensor (the TMP36) has an output voltage proportional to the temperature. </span><span class="koboSpan" id="kobo.39.3">The flowing calculation can often be found in sketches to convert an analog reading between 0 and 1023 into a temperature in degrees C.</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.40.1"><img alt="image" src="images/p72-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.41.1">But you actually only need to represent that number in floating point form when you display it. </span><span class="koboSpan" id="kobo.41.2">Other things you need to do with the temperature, for example, comparing it or averaging several temperature readings, will be much faster if the arithmetic is done in the temperature’s raw </span><b><span class="koboSpan" id="kobo.42.1">int</span></b><span class="koboSpan" id="kobo.43.1"> state.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.44.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c4-5" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.45.1">Lookup vs. </span><span class="koboSpan" id="kobo.45.2">Calculate</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.46.1">As you have seen, it’s best to avoid floats. </span><span class="koboSpan" id="kobo.46.2">But if you want to make a sine wave using an analog output, then, as the word </span><i><span class="koboSpan" id="kobo.47.1">sine</span></i><span class="koboSpan" id="kobo.48.1"> suggests, you need to use the math </span><b><span class="koboSpan" id="kobo.49.1">sin</span></b><span class="koboSpan" id="kobo.50.1"> function to “draw” the waveform on the analog output. </span><span class="koboSpan" id="kobo.50.2">To plot a sine wave on the analog output, you step an angle through 2π radians, and the value that you send to the analog output is the sin of that angle. </span><span class="koboSpan" id="kobo.50.3">Well, actually it’s a bit more complicated because you need to center the waveform about an analog output of half the maximum.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.51.1">The following code generates a sine wave in 64 steps per cycle on an Arduino Due’s DAC0 output. </span><span class="koboSpan" id="kobo.51.2">Note that only an Arduino with true analog output like the Due works for this experiment.</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.52.1"><img alt="image" src="images/p73-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.53.1">Measuring the signal on the output does, indeed, produce a nice sine wave at a frequency of just 310 Hz. </span><span class="koboSpan" id="kobo.53.2">The Arduino Due’s processor is clocked at 80 MHz, so you might have expected to generate a faster signal. </span><span class="koboSpan" id="kobo.53.3">The problem here is that you are repeating the same calculations again and again. </span><span class="koboSpan" id="kobo.53.4">Since they are the same every time, why don’t we just generate the values once and store them in an array?</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.54.1">The following code also generates a sine wave with 64 steps, but uses a lookup table of values that are ready to be written straight to the DAC.</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.55.1"><img alt="image" src="images/p73-02.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.56.1"><img alt="image" src="images/p74-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.57.1">The waveform generated by this code looks just like the one from the previous example, except that it has a frequency of 4.38 kHz, which is about 14 times faster.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.58.1">You can calculate the table of sin values in several ways. </span><span class="koboSpan" id="kobo.58.2">You can generate the numbers using nothing more complex than a spreadsheet formula, or you can write a sketch that writes the numbers to the Serial Monitor, where they can be pasted into the replacement sketch. </span><span class="koboSpan" id="kobo.58.3">Here is an example that modifies </span><b><span class="koboSpan" id="kobo.59.1">sketch_04_03_sin</span></b><span class="koboSpan" id="kobo.60.1"> to print the values once to the Serial Monitor.</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.61.1"><img alt="image" src="images/p74-02.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.62.1">Opening the Serial Monitor reveals the code that has been generated (</span><a href="#fig4-1"><span class="koboSpan" id="kobo.63.1">Figure 4-1</span></a><span class="koboSpan" id="kobo.64.1">).</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig4-1" class="image"><span><span class="koboSpan" id="kobo.65.1"><img alt="image" src="images/fig4-1.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.66.1">Figure 4-1</span></b><span class="koboSpan" id="kobo.67.1">   </span><i><span class="koboSpan" id="kobo.68.1">Using a sketch to generate code</span></i></span></div>
</div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.69.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c4-6" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.70.1">Fast I/O</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.71.1">In this section, we’ll look at how you can improve the speed when turning digital output pins on and off. </span><span class="koboSpan" id="kobo.71.2">We’ll improve a basic maximum frequency from 73 kHz up to nearly 4 MHz.</span></span></div>
<div id="c4-7" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.72.1">Basic Code Optimization</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.73.1">Let’s start with the basic code to turn a digital I/O pin on and off using </span><b><span class="koboSpan" id="kobo.74.1">digitalWrite</span></b><span class="koboSpan" id="kobo.75.1">:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.76.1"><img alt="image" src="images/p75-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.77.1">If you run this code with an oscilloscope or frequency counter attached to digital pin 10, you’ll get a frequency read of about 73 kHz (73.26 kHz on my oscilloscope).</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.78.1">Before taking the big step of using direct port manipulation, you can do a few things to optimize your C code. </span><span class="koboSpan" id="kobo.78.2">First, neither of the variables needs to be 16-bit </span><b><span class="koboSpan" id="kobo.79.1">int</span></b><span class="koboSpan" id="kobo.80.1">s; both can be changed to bytes. </span><span class="koboSpan" id="kobo.80.2">Making this change increases the frequency to 77.17 kHz. </span><span class="koboSpan" id="kobo.80.3">Next, let’s make the variable containing the pin name a constant by adding the </span><b><span class="koboSpan" id="kobo.81.1">const</span></b><span class="koboSpan" id="kobo.82.1"> keyword before the variable. </span><span class="koboSpan" id="kobo.82.2">Making this change increases the frequency to 77.92 kHz.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.83.1">In </span><a href="ch02.html"><span class="koboSpan" id="kobo.84.1">Chapter 2</span></a><span class="koboSpan" id="kobo.85.1">, you learned that the </span><b><span class="koboSpan" id="kobo.86.1">loop</span></b><span class="koboSpan" id="kobo.87.1"> function is more than just a </span><b><span class="koboSpan" id="kobo.88.1">while</span></b><span class="koboSpan" id="kobo.89.1"> loop as it also checks for serial communication. </span><span class="koboSpan" id="kobo.89.2">Therefore, the next step in improving the performance is to abandon the main </span><b><span class="koboSpan" id="kobo.90.1">loop</span></b><span class="koboSpan" id="kobo.91.1"> function and move the code into setup. </span><span class="koboSpan" id="kobo.91.2">The code containing all these modifications is shown here:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.92.1"><img alt="image" src="images/p76-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.93.1">This further improves performance, giving us a new maximum frequency of 86.39 kHz.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><a href="#tab4-2"><span class="koboSpan" id="kobo.94.1">Table 4-2</span></a><span class="koboSpan" id="kobo.95.1"> summarizes the improvements that you can make to the basic Arduino code, before taking the final step of abandoning </span><b><span class="koboSpan" id="kobo.96.1">digitalWrite</span></b><span class="koboSpan" id="kobo.97.1"> for something faster.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="tab4-2" class="imagex"><span><span class="koboSpan" id="kobo.98.1"><img alt="image" src="images/tab4-2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.99.1">Table 4-2</span></b><span class="koboSpan" id="kobo.100.1">   </span><i><span class="koboSpan" id="kobo.101.1">Speeding Up the Arduino Code</span></i></span></div>
</div>
<div id="c4-8" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.102.1">Bytes and Bits</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.103.1">Before you can manipulate the I/O ports directly, you need to understand a little about binary, bits, bytes, and </span><b><span class="koboSpan" id="kobo.104.1">int</span></b><span class="koboSpan" id="kobo.105.1">s.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><a href="#fig4-2"><span class="koboSpan" id="kobo.106.1">Figure 4-2</span></a><span class="koboSpan" id="kobo.107.1"> shows the relationship between bits and bytes.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig4-2" class="image"><span><span class="koboSpan" id="kobo.108.1"><img alt="image" src="images/fig4-2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.109.1">Figure 4-2</span></b><span class="koboSpan" id="kobo.110.1">   </span><i><span class="koboSpan" id="kobo.111.1">Bits and bytes</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.112.1">A </span><i><span class="koboSpan" id="kobo.113.1">bit</span></i><span class="koboSpan" id="kobo.114.1"> (which is short for </span><b><i><span class="koboSpan" id="kobo.115.1">bi</span></i></b><i><span class="koboSpan" id="kobo.116.1">nary digi</span></i><b><i><span class="koboSpan" id="kobo.117.1">t</span></i></b><span class="koboSpan" id="kobo.118.1">) can have one of just two values. </span><span class="koboSpan" id="kobo.118.2">It can either be 0 or 1. </span><span class="koboSpan" id="kobo.118.3">A </span><i><span class="koboSpan" id="kobo.119.1">byte</span></i><span class="koboSpan" id="kobo.120.1"> is a collection of 8 bits. </span><span class="koboSpan" id="kobo.120.2">Because each of those bits can be either a 1 or a 0, you can actually make 256 different combinations. </span><span class="koboSpan" id="kobo.120.3">A byte can be used to represent any number between 0 and 255.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.121.1">Each of those bits can also be used to indicate if something is on or off. </span><span class="koboSpan" id="kobo.121.2">So if you want to turn a particular pin on and off, you need to set a bit to 1 to make a particular output HIGH.</span></span></div>
<div id="c4-9" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.122.1">ATmega328 Ports</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><a href="#fig4-3"><span class="koboSpan" id="kobo.123.1">Figure 4-3</span></a><span class="koboSpan" id="kobo.124.1"> shows the ports on an ATmega328 and how they relate to the digital pins on an Arduino Uno.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig4-3" class="image"><span><span class="koboSpan" id="kobo.125.1"><img alt="image" src="images/fig4-3.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.126.1">Figure 4-3</span></b><span class="koboSpan" id="kobo.127.1">   </span><i><span class="koboSpan" id="kobo.128.1">ATmega328 ports</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.129.1">It is no accident that each port has 8 bits (a byte), although ports B and C only use 6 of the bits. </span><span class="koboSpan" id="kobo.129.2">Each port is controlled by three </span><i><span class="koboSpan" id="kobo.130.1">registers</span></i><span class="koboSpan" id="kobo.131.1">. </span><span class="koboSpan" id="kobo.131.2">A register can be thought of as a special variable that you can assign a value to or read the value of. </span><span class="koboSpan" id="kobo.131.3">The registers for port D are shown in </span><a href="#fig4-4"><span class="koboSpan" id="kobo.132.1">Figure 4-4</span></a><span class="koboSpan" id="kobo.133.1">.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig4-4" class="image"><span><span class="koboSpan" id="kobo.134.1"><img alt="image" src="images/fig4-4.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.135.1">Figure 4-4</span></b><span class="koboSpan" id="kobo.136.1">   </span><i><span class="koboSpan" id="kobo.137.1">The registers for port D</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.138.1">The </span><i><span class="koboSpan" id="kobo.139.1">data direction register D (DDRD)</span></i><span class="koboSpan" id="kobo.140.1"> has 8 bits, each of which determines whether the corresponding pin on the microcontroller is to be an input or an output. </span><span class="koboSpan" id="kobo.140.2">If that bit is set to a 1, the pin is an output; otherwise, it is an input. </span><span class="koboSpan" id="kobo.140.3">The Arduino </span><b><span class="koboSpan" id="kobo.141.1">pinMode</span></b><span class="koboSpan" id="kobo.142.1"> function uses this.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.143.1">The </span><i><span class="koboSpan" id="kobo.144.1">PORTD</span></i><span class="koboSpan" id="kobo.145.1"> register is used to set outputs, so a </span><b><span class="koboSpan" id="kobo.146.1">digitalWrite</span></b><span class="koboSpan" id="kobo.147.1"> sets the appropriate bit for a pin to be a 1 or a 0 (HIGH or LOW).</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.148.1">The final register is called </span><i><span class="koboSpan" id="kobo.149.1">port input D (PIND)</span></i><span class="koboSpan" id="kobo.150.1">. </span><span class="koboSpan" id="kobo.150.2">By reading this register, you can determine which bits of the port are set HIGH and which are set LOW.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.151.1">Each of the three ports has its own three ports, so for port B, they are called DDRB, PORTB, and PINB, and for Port C, they are DDRC, PORTC, and PINC.</span></span></div>
<div id="c4-10" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.152.1">Very Fast Digital Output</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.153.1">The following code uses the ports directly, rather than </span><b><span class="koboSpan" id="kobo.154.1">pinMode</span></b><span class="koboSpan" id="kobo.155.1"> and </span><b><span class="koboSpan" id="kobo.156.1">digitalWrite</span></b><span class="koboSpan" id="kobo.157.1">:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.158.1"><img alt="image" src="images/p79-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.159.1">Here, we’re switching pin D10, which belongs to port B, so first we set the third bit from the left (D10) to be a 1. </span><span class="koboSpan" id="kobo.159.2">Note the use of a binary constant </span><b><span class="koboSpan" id="kobo.160.1">B00000100</span></b><span class="koboSpan" id="kobo.161.1">. </span><span class="koboSpan" id="kobo.161.2">In the main loop, all you have to do is first set the same bit to 1 and then set it to 0 again. </span><span class="koboSpan" id="kobo.161.3">You do this simply by assigning a value to PORTB, as if it was a variable.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.162.1">When this code is run, it generates a frequency of 3.97 MHz (</span><a href="#fig4-5"><span class="koboSpan" id="kobo.163.1">Figure 4-5</span></a><span class="koboSpan" id="kobo.164.1">)—nearly 4 million pulses per second, which is some 46 times faster than using </span><b><span class="koboSpan" id="kobo.165.1">digitalWrite</span></b><span class="koboSpan" id="kobo.166.1">.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig4-5" class="image"><span><span class="koboSpan" id="kobo.167.1"><img alt="image" src="images/fig4-5.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.168.1">Figure 4-5</span></b><span class="koboSpan" id="kobo.169.1">   </span><i><span class="koboSpan" id="kobo.170.1">Generating a 4-MHz signal with an Arduino</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.171.1">The waveform is not very square, showing the kind of transients that you would expect at that frequency.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.172.1">Another advantage of using port registers directly is that you can write to up to eight output pins simultaneously, which is very useful if you are writing to a parallel data bus.</span></span></div>
<div id="c4-11" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.173.1">Fast Digital Input</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.174.1">You can also use the same method of accessing the port registers directly to speed up digital reads. </span><span class="koboSpan" id="kobo.174.2">Although, if you are thinking of doing this because you want to catch a very short pulse, then using interrupts is probably best (see </span><a href="ch03.html"><span class="koboSpan" id="kobo.175.1">Chapter 3</span></a><span class="koboSpan" id="kobo.176.1">).</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.177.1">One situation in which using the ports directly is helpful is when you want to read a number of bits simultaneously. </span><span class="koboSpan" id="kobo.177.2">The following sketch reads all the inputs of port B (D8 to D13) and writes the result as a binary number in the Serial Monitor (</span><a href="#fig4-6"><span class="koboSpan" id="kobo.178.1">Figure 4-6</span></a><span class="koboSpan" id="kobo.179.1">).</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig4-6" class="image"><span><span class="koboSpan" id="kobo.180.1"><img alt="image" src="images/fig4-6.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.181.1">Figure 4-6</span></b><span class="koboSpan" id="kobo.182.1">   </span><i><span class="koboSpan" id="kobo.183.1">Reading eight inputs at once</span></i></span></div>
</div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.184.1"><img alt="image" src="images/p80-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.185.1"><img alt="image" src="images/p81-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.186.1">The DDRB register sets all bits to 0, designating all the pins to be inputs. </span><span class="koboSpan" id="kobo.186.2">In the loop, you use </span><b><span class="koboSpan" id="kobo.187.1">Serial.println</span></b><span class="koboSpan" id="kobo.188.1"> to send the number back to the Serial Monitor, where it is displayed in binary. </span><span class="koboSpan" id="kobo.188.2">To force it to display in binary rather than the default of decimal, use the extra </span><b><span class="koboSpan" id="kobo.189.1">2</span></b><span class="koboSpan" id="kobo.190.1"> argument.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.191.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c4-12" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.192.1">Speeding Up Analog Inputs</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.193.1">Let’s start by adapting the benchmark sketch to see just how long an </span><b><span class="koboSpan" id="kobo.194.1">analogRead</span></b><span class="koboSpan" id="kobo.195.1"> takes before trying to speed it up:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.196.1"><img alt="image" src="images/p81-02.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.197.1"><img alt="image" src="images/p82-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.198.1">This sketch takes 112 seconds to run on an Arduino Uno. </span><span class="koboSpan" id="kobo.198.2">That means the Uno can take nearly 9000 analog readings per second.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.199.1">The </span><b><span class="koboSpan" id="kobo.200.1">analogRead</span></b><span class="koboSpan" id="kobo.201.1"> function uses an analog-to-digital converter (ADC) in the Arduino’s microcontroller. </span><span class="koboSpan" id="kobo.201.2">Arduino uses a type of ADC called a </span><i><span class="koboSpan" id="kobo.202.1">successive approximation ADC</span></i><span class="koboSpan" id="kobo.203.1">. </span><span class="koboSpan" id="kobo.203.2">It works by effectively closing in on the analog value by comparing it with a reference voltage that it adjusts. </span><span class="koboSpan" id="kobo.203.3">The ADC is controlled by a timer, and you can increase the frequency to make the conversion quicker.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.204.1">The following code increases the frequency of the ADC from 128 kHz to 1 MHz, which should make things about eight times faster:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.205.1"><img alt="image" src="images/p82-02.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.206.1"><img alt="image" src="images/p83-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.207.1">The code now takes only 17 seconds to run, which is roughly 6.5 times faster, increasing our samples per second to about 58,000. </span><span class="koboSpan" id="kobo.207.2">That is plenty fast enough to sample audio, although you won’t be able to store much of it in 2kB of RAM!</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.208.1">If the original sketch_04_11_analog is run on an Arduino Due, the test completes in 39 seconds. </span><span class="koboSpan" id="kobo.208.2">You cannot use the register trick we just tried on the Due, however, as it has a different architecture.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.209.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c4-13" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.210.1">Summary</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.211.1">In this chapter, we tried to squeeze the last possible drop of juice out of our meager 16 MHz of processor power. </span><span class="koboSpan" id="kobo.211.2">In the next chapter, we’ll switch our attention to minimizing the Arduino’s power consumption, something that is quite important for battery- and solar-powered Arduino projects.</span></span></div>
</div></div></body>
</html>