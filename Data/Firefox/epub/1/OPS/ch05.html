<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.1//EN' 'http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd'>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Programming Arduino™ Next Steps: Going Further with Sketches</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"></meta>
<link href="stylesheet.css" type="text/css" rel="stylesheet"></link>

<!-- kobo-style -->
<link type="text/css" rel="stylesheet" href="css/kobo.css"></link>
<script type="text/javascript" src="js/kobo.js"></script>
<style type="text/css" id="kobostylehacks">div#book-inner p, div#book-inner div { font-size: 1.0em; } a { color: black; } a:link, a:visited, a:hover, a:active { color: blue; } div#book-inner * { margin-top: 0 !important; margin-bottom: 0 !important;}</style>
</head>
<body><div id="book-columns"><div id="book-inner">
<div class="chapnum" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.1.1">5</span></span></div>
<div class="chaptitle" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.2.1">Low Power Arduino</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="big"><span class="koboSpan" id="kobo.3.1">It is</span></span><span class="koboSpan" id="kobo.4.1"> fair to say that, without taking any special measures, an Arduino really does not use a lot of power. </span><span class="koboSpan" id="kobo.4.2">Typically, an Arduino Uno draws about 40 mA, which when powered from USB at 5V amounts to just 200 mW. </span><span class="koboSpan" id="kobo.4.3">That means it can happily run on a small 9V battery (150 mAh) for perhaps four hours.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.5.1">Current consumption becomes important when the Arduino is being run for long periods of time using batteries, such as in remote monitoring or control situations in which batteries or solar are the only option. </span><span class="koboSpan" id="kobo.5.2">For instance, I recently made an Arduino-based automatic hen-house door, using a small solar panel to charge the battery so it had enough juice to open and close the door twice a day.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.6.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c5-1" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.7.1">Power Consumption of Arduino Boards</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.8.1">Let’s establish some initial figures for the power consumption of a few of the more popular Arduino boards. </span><a href="#tab5-1"><span class="koboSpan" id="kobo.9.1">Table 5-1</span></a><span class="koboSpan" id="kobo.10.1"> shows the results of directly measuring the current consumption of the boards with an ammeter. </span><span class="koboSpan" id="kobo.10.2">Note that measuring this is a little tricky as the current varies as timers and other parts of the microcontroller and Arduino board perform periodic tasks.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="tab5-1" class="imagex"><span><span class="koboSpan" id="kobo.11.1"><img alt="image" src="images/tab5-1.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.12.1">Table 5-1</span></b><span class="koboSpan" id="kobo.13.1">   </span><i><span class="koboSpan" id="kobo.14.1">Power Consumption for Arduino Boards</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.15.1">One interesting thing is that if you look at the difference between an Arduino operating at 5V with and without the processor chip, the difference is just 15 mA, implying that the board itself is using the other 32 mA. </span><span class="koboSpan" id="kobo.15.2">The Arduino board does, of course, have the USB interface chip, an “On” LED, and 3.3V voltage regulators, all of which use some power even without the microcontroller. </span><span class="koboSpan" id="kobo.15.3">Note also how much less current the microcontroller draws at 3.3V.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.16.1">The techniques described here can reduce the power required by the processor but not that required by the board itself. </span><span class="koboSpan" id="kobo.16.2">In the examples that follow, I use the Arduino Mini Pro board supplied directly with 3.3V through its VCC and GND connections (</span><a href="#fig5-1"><span class="koboSpan" id="kobo.17.1">Figure 5-1</span></a><span class="koboSpan" id="kobo.18.1">), bypassing the voltage regulator, so that apart from the “On” LED, I am only powering the microcontroller chip.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig5-1" class="image"><span><span class="koboSpan" id="kobo.19.1"><img alt="image" src="images/fig5-1.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.20.1">Figure 5-1</span></b><span class="koboSpan" id="kobo.21.1">   </span><i><span class="koboSpan" id="kobo.22.1">An Arduino Mini Pro, powered directly from 3V</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.23.1">This setup is one you would be likely to use in a battery-operated system, as a single lithium polymer (LiPo) battery cell provides 2.7V when almost empty and 4.2V when full, a range that is just fine for a naked ATmega328 microcontroller.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.24.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c5-2" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.25.1">Current and Batteries</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.26.1">This book is about software, so I will not dwell on batteries any longer than is necessary. </span><a href="#fig5-2"><span class="koboSpan" id="kobo.27.1">Figure 5-2</span></a><span class="koboSpan" id="kobo.28.1"> shows a selection of batteries that you might consider for powering an Arduino.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig5-2" class="image"><span><span class="koboSpan" id="kobo.29.1"><img alt="image" src="images/fig5-2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.30.1">Figure 5-2</span></b><span class="koboSpan" id="kobo.31.1">   </span><i><span class="koboSpan" id="kobo.32.1">Batteries for powering Arduino boards</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.33.1">At the top-left is a 2400mAh LiPo cylindrical LiPo battery. </span><span class="koboSpan" id="kobo.33.2">Below is a small, flat 850mAh LiPo battery. </span><span class="koboSpan" id="kobo.33.3">LiPo batteries are lightweight and can be recharged many times and hold a lot of energy for their size and weight. </span><span class="koboSpan" id="kobo.33.4">At the top-right is a 9V NiMh battery, with a capacity of 200 mAh. </span><span class="koboSpan" id="kobo.33.5">This battery is also rechargeable but uses an older technology. </span><span class="koboSpan" id="kobo.33.6">Because it is a 9V battery, it would be suitable for powering an Arduino only when using the Arduino’s voltage regulator. </span><span class="koboSpan" id="kobo.33.7">You can buy battery clip adapters that allow you to connect the battery to the barrel jack on an Arduino. </span><span class="koboSpan" id="kobo.33.8">Finally, at the bottom-right is a 3V nonrechargeable Lithium battery (CR2025) that has a capacity of about 160 mAH.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.34.1">As a rule of thumb, you can calculate the number of hours that a battery will last before it is discharged by dividing the capacity in milliamp hour (mAh) by the number of milliamps (mA) being drawn:</span></span></div>
<div class="center" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.35.1">Battery life in hours = Battery capacity in mAh / Current in mA</span></span></div>
<div class="noindent1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.36.1">For example, if we were to use the CR2025 to power a Mini Pro at 3V, we could expect it to last 160mAh/8mA = 20 hours. </span><span class="koboSpan" id="kobo.36.2">If we powered the same hardware from the 2400 mA LiPo cell, we could expect it to last 2400/8 = 300 hours.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.37.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c5-3" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.38.1">Reducing the Clock Speed</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.39.1">Most of the Arduino family has a clock frequency of 16 MHz. </span><span class="koboSpan" id="kobo.39.2">The microcontroller only really uses significant amounts of current when its binary logic is switching from a HIGH to a LOW, so the frequency at which the chip operates has a big effect on the current consumed. </span><span class="koboSpan" id="kobo.39.3">Lowering the frequency will, of course, make the microcontroller perform more slowly, which may or may not be a problem.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.40.1">You can lower the frequency at which an ATmega328 chip operates from within your sketch. </span><span class="koboSpan" id="kobo.40.2">A convenient way to do this is to use the Arduino Prescaler library (</span><a href="http://playground.arduino.cc/Code/Prescaler"><span class="koboSpan" id="kobo.41.1">http://playground.arduino.cc/Code/Prescaler</span></a><span class="koboSpan" id="kobo.42.1">).</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.43.1">As well as allowing you to set the microcontroller’s frequency of operation, the Prescaler library also provides replacement functions for </span><b><span class="koboSpan" id="kobo.44.1">millis</span></b><span class="koboSpan" id="kobo.45.1"> and </span><b><span class="koboSpan" id="kobo.46.1">delay</span></b><span class="koboSpan" id="kobo.47.1"> called </span><b><span class="koboSpan" id="kobo.48.1">trueMillis</span></b><span class="koboSpan" id="kobo.49.1"> and </span><b><span class="koboSpan" id="kobo.50.1">trueDelay</span></b><span class="koboSpan" id="kobo.51.1">. </span><span class="koboSpan" id="kobo.51.2">These replacements are necessary because reducing the clock frequency will increase the length of a delay by the same proportion.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.52.1">The following example sketch turns the “L” LED on for 1 second and then off for 5 seconds, during which the current is measured for each of the possible Prescaler values that set the frequency.</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.53.1"><img alt="image" src="images/p88-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.54.1"><img alt="image" src="images/p89-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.55.1">The library provides a number of constants so you can set the amount by which the clock frequency is divided. </span><span class="koboSpan" id="kobo.55.2">Therefore, the value </span><b><span class="koboSpan" id="kobo.56.1">CLOCK_PRESCALER_1</span></b><span class="koboSpan" id="kobo.57.1"> leaves the clock frequency unchanged at 16 MHz and, at the other extreme, using the constant </span><b><span class="koboSpan" id="kobo.58.1">CLOCK_PRESCALER_256</span></b><span class="koboSpan" id="kobo.59.1"> will divide the clock frequency by 256, giving a clock frequency of just 62.5 kHz.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><a href="#tab5-2"><span class="koboSpan" id="kobo.60.1">Table 5-2</span></a><span class="koboSpan" id="kobo.61.1"> show the current consumption at each of the possible clock frequencies, and </span><a href="#fig5-3"><span class="koboSpan" id="kobo.62.1">Figure 5-3</span></a><span class="koboSpan" id="kobo.63.1"> shows these data on a chart. </span><span class="koboSpan" id="kobo.63.2">The chart shows that the curve starts to level off fairly steeply, so 1 MHz looks like a good compromise of clock frequency verses power consumption.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="tab5-2" class="imagex"><span><span class="koboSpan" id="kobo.64.1"><img alt="image" src="images/tab5-2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.65.1">Table 5-2</span></b><span class="koboSpan" id="kobo.66.1">   </span><i><span class="koboSpan" id="kobo.67.1">Current Consumption vs. </span><span class="koboSpan" id="kobo.67.2">Clock Speed</span></i></span></div>
</div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig5-3" class="image"><span><span class="koboSpan" id="kobo.68.1"><img alt="image" src="images/fig5-3.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.69.1">Figure 5-3</span></b><span class="koboSpan" id="kobo.70.1">   </span><i><span class="koboSpan" id="kobo.71.1">A chart of current consumption vs. </span><span class="koboSpan" id="kobo.71.2">clock speed</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.72.1">As well as having to use new versions of </span><b><span class="koboSpan" id="kobo.73.1">millis</span></b><span class="koboSpan" id="kobo.74.1"> and </span><b><span class="koboSpan" id="kobo.75.1">delay</span></b><span class="koboSpan" id="kobo.76.1">, there are other consequences of stopping the clock speed. </span><span class="koboSpan" id="kobo.76.2">In fact, any task in which timing is critical, such as PWM output and Servo control, is not going to work as expected.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.77.1">Most of that 2.1 mA, used at the slowest clock speed, is likely to be consumed by the “On” LED, so if you really want to be economical, you could carefully de-solder it.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.78.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c5-4" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.79.1">Turning Things Off</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.80.1">The ATmega chips have very sophisticated power management, to the extent that you can actually turn off features that you are not using to save a small amount of current.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.81.1">What is more, you can turn things on and off in your sketch. </span><span class="koboSpan" id="kobo.81.2">So you could, for example, just turn on the analog-to-digital converter (ADC) when you need to do an </span><b><span class="koboSpan" id="kobo.82.1">analogRead</span></b><span class="koboSpan" id="kobo.83.1"> and then turn it off again afterward.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.84.1">The power is controlled using a library </span><b><span class="koboSpan" id="kobo.85.1">avr/power.h</span></b><span class="koboSpan" id="kobo.86.1"> that includes functions in disable/enable pairs. </span><span class="koboSpan" id="kobo.86.2">So the function </span><b><span class="koboSpan" id="kobo.87.1">power_adc_disable</span></b><span class="koboSpan" id="kobo.88.1"> turns the ADC off and </span><b><span class="koboSpan" id="kobo.89.1">power_adc_enable</span></b><span class="koboSpan" id="kobo.90.1"> turns it back on again.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.91.1">The power savings to be had are not great, however. </span><span class="koboSpan" id="kobo.91.2">In my testing, turning everything off on a Mini Pro at 5V and 16 MHz saved a total of just 1.5 mA, reducing the current from 16.4 mA with everything on, to 14.9 with everything off. </span><span class="koboSpan" id="kobo.91.3">I used the following test sketch:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.92.1"><img alt="image" src="images/p91-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.93.1">The functions available are listed in </span><a href="#tab5-3"><span class="koboSpan" id="kobo.94.1">Table 5-3</span></a><span class="koboSpan" id="kobo.95.1">. </span><span class="koboSpan" id="kobo.95.2">Each function also has a counterpart, ending in </span><b><span class="koboSpan" id="kobo.96.1">enable</span></b><span class="koboSpan" id="kobo.97.1"> rather than </span><b><span class="koboSpan" id="kobo.98.1">disable</span></b><span class="koboSpan" id="kobo.99.1">.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="tab5-3" class="imagex"><span><span class="koboSpan" id="kobo.100.1"><img alt="image" src="images/tab5-3.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.101.1">Table 5-3</span></b><span class="koboSpan" id="kobo.102.1">   </span><i><span class="koboSpan" id="kobo.103.1">Power Management Functions for ATmega Arduinos</span></i></span></div>
</div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.104.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c5-5" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.105.1">Sleeping</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.106.1">The ultimate way to save power on your Arduino is to put it to sleep when it doesn’t have anything useful to do.</span></span></div>
<div id="c5-6" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.107.1">Narcoleptic</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.108.1">Peter Knight has produced an easy-to-use library called </span><i><span class="koboSpan" id="kobo.109.1">Narcoleptic</span></i><span class="koboSpan" id="kobo.110.1">, which you can download from here: </span><a href="https://code.google.com/p/narcoleptic/"><span class="koboSpan" id="kobo.111.1">https://code.google.com/p/narcoleptic/</span></a><span class="koboSpan" id="kobo.112.1">.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.113.1">Obviously, putting an Arduino to sleep is of no use if you can’t wake it up again! </span><span class="koboSpan" id="kobo.113.2">There are two methods to wake up an Arduino. </span><span class="koboSpan" id="kobo.113.3">One is to use an external interrupt and the other is to set a timer to wake the Arduino after a period of time. </span><span class="koboSpan" id="kobo.113.4">The Narcoleptic library just uses the timer method.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.114.1">The Narcoleptic library takes the approach of providing you with an alternative </span><b><span class="koboSpan" id="kobo.115.1">delay</span></b><span class="koboSpan" id="kobo.116.1"> function that puts the Arduino to sleep for the time specified in the </span><b><span class="koboSpan" id="kobo.117.1">delay</span></b><span class="koboSpan" id="kobo.118.1">. </span><span class="koboSpan" id="kobo.118.2">Because nothing happens when the Arduino is doing a </span><b><span class="koboSpan" id="kobo.119.1">delay</span></b><span class="koboSpan" id="kobo.120.1"> anyway, this method works brilliantly.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.121.1">For example, let’s look at our old favorite sketch, Blink. </span><span class="koboSpan" id="kobo.121.2">The following sketch turns an LED on for 1 second and then turns it off for 10 seconds and repeats indefinitely:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.122.1"><img alt="image" src="images/p92-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.123.1">The Narcoleptic version of this sketch is shown here:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.124.1"><img alt="image" src="images/p92-02.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.125.1"><img alt="image" src="images/p93-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.126.1">The only difference is that you import the Narcoleptic library and use its </span><b><span class="koboSpan" id="kobo.127.1">delay</span></b><span class="koboSpan" id="kobo.128.1"> rather than the regular </span><b><span class="koboSpan" id="kobo.129.1">delay</span></b><span class="koboSpan" id="kobo.130.1">.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.131.1">Running both sketches on a Mini Pro at 5V and 16 MHz, the first sketch uses around 17.2 mA when the LED is in the off part of the cycle. </span><span class="koboSpan" id="kobo.131.2">On the other hand, the Narcoleptic version of the sketch reduces this to a tiny 3.2 mA. </span><span class="koboSpan" id="kobo.131.3">The “On” LED uses most of that (about 3 mA), so if you remove it, then your average power consumption could be reduced to well under 1 mA.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.132.1">The microcontroller can go to sleep pretty quickly, so if your project relies on a button being pressed to trigger some action, you do not necessarily need to use an external interrupt to wake it from sleep. </span><span class="koboSpan" id="kobo.132.2">But you could (probably more easily) write your code so the Arduino wakes 10 times a second, checks to see if an input is HIGH, and then, if it is, does something rather than go back to sleep. </span><span class="koboSpan" id="kobo.132.3">The following sketch illustrates this process:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.133.1"><img alt="image" src="images/p93-02.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.134.1"><img alt="image" src="images/p94-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.135.1">When running this sketch, a Mini Pro at 5V and 16 MHz uses a miserly 3.25 mA while the Arduino waits for something to happen. </span><span class="koboSpan" id="kobo.135.2">When pin2 is connected to ground, the LED is flashed 20 times, but because you are using the Narcoleptic </span><b><span class="koboSpan" id="kobo.136.1">delay</span></b><span class="koboSpan" id="kobo.137.1"> in the LED flashing too, the current only rises to an average of 4 or 5 mA.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.138.1">If you change the </span><b><span class="koboSpan" id="kobo.139.1">delay</span></b><span class="koboSpan" id="kobo.140.1"> inside the loop, to try and make the Arduino wake, say, 100 times per second, the power will rise again because it does take a little while for the Arduino to go to sleep. </span><span class="koboSpan" id="kobo.140.2">A delay of 50 (20 times a second), however, would work just fine.</span></span></div>
<div id="c5-7" class="head1" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.141.1">Waking on External Interrupts</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.142.1">The approach just described works for most situations; however, if you need to respond more quickly to an external event, then you need to arrange for the microcontroller to wake up when an external interrupt occurs.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.143.1">To rework the previous example to use pin D2 as an external interrupt pin is a lot more work, but it achieves slightly better results, as it does not require polling the interrupt pin. </span><span class="koboSpan" id="kobo.143.2">The code for this is quite complex, so first I’ll show you the code and then describe how it all works. </span><span class="koboSpan" id="kobo.143.3">If you skipped </span><a href="ch03.html"><span class="koboSpan" id="kobo.144.1">Chapter 3</span></a><span class="koboSpan" id="kobo.145.1"> on interrupts, then you should probably read it before tackling this example.</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.146.1"><img alt="image" src="images/p95-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.147.1"><img alt="image" src="images/p96-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.148.1">The first thing to note is that the example uses some functions that are defined in the library </span><b><span class="koboSpan" id="kobo.149.1">avr/sleep.h</span></b><span class="koboSpan" id="kobo.150.1">. </span><span class="koboSpan" id="kobo.150.2">Just like </span><b><span class="koboSpan" id="kobo.151.1">avr/power.h</span></b><span class="koboSpan" id="kobo.152.1"> that I used earlier, this library is not part of the Arduino core, but rather a library for the AVR family of microcontrollers. </span><span class="koboSpan" id="kobo.152.2">This means it will not work on the Arduino Due, but then again, if you are making a low-power Arduino project, the Due should be just about your last choice of board.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.153.1">After defining the pins I am going to use, I then define a </span><b><span class="koboSpan" id="kobo.154.1">volatile</span></b><span class="koboSpan" id="kobo.155.1"> variable to allow the ISR to communicate with the rest of the sketch.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.156.1">The </span><b><span class="koboSpan" id="kobo.157.1">setup</span></b><span class="koboSpan" id="kobo.158.1"> function sets up the pins and then calls the function </span><b><span class="koboSpan" id="kobo.159.1">goToSleep</span></b><span class="koboSpan" id="kobo.160.1">. </span><span class="koboSpan" id="kobo.160.2">This function sets the type of sleep mode, which, in this case, is </span><b><span class="koboSpan" id="kobo.161.1">SLEEP_MODE_PWR_DOWN</span></b><span class="koboSpan" id="kobo.162.1">. </span><span class="koboSpan" id="kobo.162.2">This mode saves the most power, so it makes sense to use it.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.163.1">It is then necessary to call </span><b><span class="koboSpan" id="kobo.164.1">sleep_enable</span></b><span class="koboSpan" id="kobo.165.1">. </span><span class="koboSpan" id="kobo.165.2">Calling this does not actually put the microcontroller to sleep. </span><span class="koboSpan" id="kobo.165.3">Before I do that, I need to attach an interrupt to interrupt 0 (pin D2) so the Arduino can be woken when the time comes.</span></span></div>
<div class="note" xmlns="http://www.w3.org/1999/xhtml"><span><b><i><span class="koboSpan" id="kobo.166.1">NOTE</span></i></b><span class="koboSpan" id="kobo.167.1">   </span><i><span class="koboSpan" id="kobo.168.1">Notice that the interrupt type is set to</span></i> <b><span class="koboSpan" id="kobo.169.1">LOW</span></b><span class="koboSpan" id="kobo.170.1">. </span><i><span class="koboSpan" id="kobo.171.1">This is the only interrupt type that you can use with this sleep example. </span><span class="koboSpan" id="kobo.171.2">RISING, FALLING, and CHANGE will not work</span></i><span class="koboSpan" id="kobo.172.1">.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.173.1">Having attached the interrupt, calling </span><b><span class="koboSpan" id="kobo.174.1">sleep_mode()</span></b><span class="koboSpan" id="kobo.175.1"> actually puts the process to sleep. </span><span class="koboSpan" id="kobo.175.2">When the microcontroller eventually wakes, the ISR is run and then the sketch continues from the next line in </span><b><span class="koboSpan" id="kobo.176.1">goToSleep</span></b><span class="koboSpan" id="kobo.177.1">. </span><span class="koboSpan" id="kobo.177.2">This first calls </span><b><span class="koboSpan" id="kobo.178.1">disable_sleep</span></b><span class="koboSpan" id="kobo.179.1"> and then detaches the interrupt, so the ISR cannot be invoked again until the sketch has put itself back to sleep.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.180.1">When an interrupt occurs on D2, the ISR (</span><b><span class="koboSpan" id="kobo.181.1">setFlag</span></b><span class="koboSpan" id="kobo.182.1">) simply sets a flag that the </span><b><span class="koboSpan" id="kobo.183.1">loop</span></b><span class="koboSpan" id="kobo.184.1"> function checks. </span><span class="koboSpan" id="kobo.184.2">Remember that using </span><b><span class="koboSpan" id="kobo.185.1">delay</span></b><span class="koboSpan" id="kobo.186.1">s and so on, in an ISR are a no-no. </span><span class="koboSpan" id="kobo.186.2">The </span><b><span class="koboSpan" id="kobo.187.1">loop</span></b><span class="koboSpan" id="kobo.188.1"> function must, therefore, monitor the flag until it becomes set and then call the same </span><b><span class="koboSpan" id="kobo.189.1">doSomething</span></b><span class="koboSpan" id="kobo.190.1"> function that was used in the Narcoleptic example. </span><span class="koboSpan" id="kobo.190.2">Having performed the action, the flag is reset and the Arduino put back to sleep.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.191.1">The power consumption level was pretty much the same as in the Narcoleptic example, except that while flashing the LEDs, the current consumption was higher as the normal </span><b><span class="koboSpan" id="kobo.192.1">delay</span></b><span class="koboSpan" id="kobo.193.1"> function was used.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.194.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c5-8" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.195.1">Use Digital Outputs to Control Power</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.196.1">Although this chapter is really about using software to minimize power consumption, it would not be out of place to mention a useful hardware tip to keep the power consumption low.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><a href="#fig5-4"><span class="koboSpan" id="kobo.197.1">Figure 5-4</span></a><span class="koboSpan" id="kobo.198.1"> shows a light sensor using a photoresistor (resistance changes with light) and a fixed resistor connected to an Arduino analog input that is measuring the light intensity.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig5-4" class="image"><span><span class="koboSpan" id="kobo.199.1"><img alt="image" src="images/fig5-4.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.200.1">Figure 5-4</span></b><span class="koboSpan" id="kobo.201.1">   </span><i><span class="koboSpan" id="kobo.202.1">Measuring light with an LDR (Photoresistor)</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.203.1">The problem with this approach is that there is a constant current flowing from 5V through the photoresistor and then through the fixed resistor. </span><span class="koboSpan" id="kobo.203.2">If the photoresistor has a “bright” resistance of 500Ω, then, using Ohm’s Law, the current flowing is I = V/R = 5V / (1000Ω + 500Ω) = 3.3 mA.</span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.204.1">Instead of using the fixed 5V supply of the Arduino, you could use a digital output (see </span><a href="#fig5-5"><span class="koboSpan" id="kobo.205.1">Figure 5-5</span></a><span class="koboSpan" id="kobo.206.1">) to turn the pin HIGH, take a reading, and then turn it LOW again. </span><span class="koboSpan" id="kobo.206.2">In this way, the 3.3 mA only flows for a tiny amount of time every time a reading is taken, reducing the average current consumption enormously.</span></span></div>
<div class="break" xmlns="http://www.w3.org/1999/xhtml">
<div id="fig5-5" class="image"><span><span class="koboSpan" id="kobo.207.1"><img alt="image" src="images/fig5-5.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="caption"><span><b><span class="koboSpan" id="kobo.208.1">Figure 5-5</span></b><span class="koboSpan" id="kobo.209.1">   </span><i><span class="koboSpan" id="kobo.210.1">Measuring light economically</span></i></span></div>
</div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.211.1">The following sketch illustrates this approach:</span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.212.1"><img alt="image" src="images/p97-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="image3" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.213.1"><img alt="image" src="images/p98-01.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div class="indent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.214.1">You can use this technique for a lot more than just light sensing. </span><span class="koboSpan" id="kobo.214.2">You could, for example, use the digital output to use a MOSFET transistor to turn high-power parts of your project on and off as required.</span></span></div>
<div class="image2" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.215.1"><img width="100%" alt="image" src="images/line2.jpg" xmlns="http://www.w3.org/1999/xhtml"></img></span></span></div>
<div id="c5-9" class="head" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.216.1">Summary</span></span></div>
<div class="noindent" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.217.1">The best ways to minimize current consumption are to:</span></span></div>
<div class="hangbull" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.218.1">•  Put the microcontroller to sleep when it’s not doing anything</span></span></div>
<div class="hangbull" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.219.1">•  Run the Arduino at a lower voltage</span></span></div>
<div class="hangbull" xmlns="http://www.w3.org/1999/xhtml"><span><span class="koboSpan" id="kobo.220.1">•  Run the Arduino at a lower clock frequency</span></span></div>
</div></div></body>
</html>